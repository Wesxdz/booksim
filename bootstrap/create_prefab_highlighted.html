<html><body><p>Flecs: Manual</p><p>FlecsÂ v3.2</p><p>A fast entity component system (ECS) for C & C++</p><p>Loading...</p><p>Searching...</p><p>No Matches</p><p>Manual</p><p># Introduction</p><p>Nobody likes to read manuals, and you should be able to get up and running with Flecs by using the quickstart, by looking at examples and by checking the documentation in the flecs header files. However, if you truly want to know how something works, or why it works that way, the manual is the right place to go. With that said, the manual is not exhaustive, and it complements the other sources of documentation.</p><p># Design Goals</p><p>## 1. Performance</p><p>Flecs is designed from the ground up to provide blazing fast iteration speeds in systems that can be vectorized by default, while minimizing cache misses. In addition, Flecs has a unique graph-based storage engine that allows for extremely fast add, remove and bulk operations. These features, amongst others, ensure that applications can get the most out of the underlying hardware.</p><p>## 2. Portability</p><p>Flecs has been implemented in C99 and features an external interface that is C89 compatible to ensure it is portable to a wide range of platforms. The framework contains a flexible operating system abstraction API that enables an application to easily port the library to new platforms.</p><p>## 3. Reusability</p><p>ECS has the potential for being a platform for the development of reusable, loosely coupled, plug and play features like input, physics and rendering. Flecs modules enable such features to be packaged in a loosely coupled way so that applications can simply import them, while guaranteeing a correct execution order. In addition, Flecs has features like time management that ensure a consistent baseline across modules.</p><p>## 4. Usability</p><p>Flecs is designed first and foremost to be a framework that simplifies the development of games and simulations. Rather than just providing a vanilla ECS implementation, Flecs provides many features that are commonly found in game development frameworks such as hierarchies, prefabs and time management, all integrated seamlessly with the core ECS system.</p><p>## 5. Extensibility</p><p>Flecs is used with other frameworks and game engines, and as such not all of its features are useful in each application. For that reason Flecs has a modular design, so that applications can easily remove features from the core that they do not need. Additionally, since many features are built on top of the ECS core, applications can easily extend or reimplement them.</p><p>## 6. Have fun!</p><p style="background-color:lightgreen">There are few things as satisfying as building games. If nothing else, Flecs has been built to enable creative visions both big and small. I'm having a lot of fun building Flecs, I hope you will have fun using it, and that your users will have fun playing your games :)</p><p># Diagrams</p><p>## High level architecture</p><p>This diagram provides an overview of how entities, components, tables, queries, filters and systems are wired together.</p><p>## Component add flow</p><p>This diagram provides an overview of the different steps that occur when adding a component to an entity. The diagram shows when component lifecycle callbacks, OnAdd triggers, OnSet systems, UnSet systems and monitors are invoked. Additionally the diagram shows how the defer mechanism is integrated with the listed Flecs operations.</p><p style="background-color:lightgreen">## Component remove flow</p><p>This diagram provides an overview of the different steps that occur when removing a component from an entity. The diagram shows when component lifecycle callbacks, OnRemove triggers, OnSet systems, UnSet systems and monitors are invoked. Additionally the diagram shows how the defer mechanism is integrated with the listed Flecs operations.</p><p>## Staging flow</p><p>This diagram provides an overview of what happens when an application uses staging. Staging is a lockless mechanism that lets threads concurrently read & perform structural changes on the store. Changes are temporarily stored in a command queue per stage, which can be merged with the store when convenient.</p><p># API design</p><p style="background-color:lightgreen">## Naming conventions</p><p style="background-color:lightgreen">// Component names ('Position') use PascalCase</p><p style="background-color:lightgreen">typedef struct Position {</p><p style="background-color:lightgreen">float x;</p><p style="background-color:lightgreen">float y; // Component members ('y') use snake_case</p><p style="background-color:lightgreen">} Position;</p><p>typedef struct Velocity {</p><p>float x;</p><p>float y;</p><p>} Velocity;</p><p>// System names ('Move') use PascalCase. API types use snake_case_t</p><p>void Move(ecs_iter_t *it) {</p><p>// Functions use snake_case</p><p>Position *p = ecs_field(it, Position, 1);</p><p>Velocity *v = ecs_field(it, Velocity, 2);</p><p>for (int i = 0; i < it->count; i++) {</p><p>p[i].x += v[i].x;</p><p>p[i].y += v[i].y;</p><p>}</p><p>}</p><p>int main(int argc, char *argv[]) {</p><p>ecs_world_t *world = ecs_init();</p><p>// Declarative function-style macros use SCREAMING_SNAKE_CASE</p><p style="background-color:lightgreen">ECS_COMPONENT(world, Position);</p><p>ECS_COMPONENT(world, Velocity);</p><p style="background-color:lightgreen">// Module names are PascalCase</p><p>ECS_IMPORT(world, MyModule);</p><p>// Enumeration constants ('EcsOnUpdate') use PascalCase</p><p style="background-color:lightgreen">ECS_SYSTEM(world, Move, EcsOnUpdate, Position, Velocity);</p><p style="background-color:lightgreen">// Function wrapper macros use snake_case</p><p>ecs_entity_t e = ecs_new(world, 0);</p><p>// Builtin entities use PascalCase</p><p>ecs_add(world, EcsWorld, Position);</p><p>return ecs_fini(world);</p><p>}</p><p>EcsWorldconst ecs_entity_t EcsWorldEntity associated with world (used for "attaching" components to world)</p><p>ECS_IMPORT#define ECS_IMPORT(world, id)Wrapper around ecs_import.Definition: module.h:116</p><p>ECS_SYSTEM#define ECS_SYSTEM(world, id, phase,...)Declare & define a system.Definition: system.h:131</p><p>ecs_entity_tecs_id_t ecs_entity_tAn entity identifier.Definition: flecs.h:282</p><p>ecs_world_tstruct ecs_world_t ecs_world_tA world is the container for all ECS data and supporting features.Definition: flecs.h:291</p><p>ECS_COMPONENT#define ECS_COMPONENT(world, id)Declare & define a component.Definition: flecs_c.h:120</p><p>ecs_finiint ecs_fini(ecs_world_t *world)Delete a world.</p><p>ecs_initecs_world_t * ecs_init(void)Create a new world.</p><p>## Idempotence</p><p>Many operations in the Flecs API are idempotent, meaning that invoking an operation once has the same effect as invoking an operation multiple times with the same parameters. For example:</p><p>ecs_add(world, e, Position);</p><p>Has the same effect as:</p><p>ecs_add(world, e, Position);</p><p>ecs_add(world, e, Position);</p><p>This simplifies application code as it can be written in a declarative style, where the only thing that matters is that after the operation has been invoked, the post condition of the operation is satisfied.</p><p>Some operations are idempotent but have side effects, like ecs_set:</p><p>ecs_set(world, e, Position, {10, 20});</p><p>ecs_set(world, e, Position, {10, 20});</p><p>The effect of invoking this operation once is the same as invoking the operation multiple times, but both invocations can invoke an OnSet observer which can introduce side effects.</p><p>All declarative macros (ECS_COMPONENT, ECS_SYSTEM, ...) are idempotent:</p><p>{</p><p>ECS_COMPONENT(world, Position);</p><p>}</p><p>{</p><p>ECS_COMPONENT(world, Position);</p><p>}</p><p>The second time the ECS_COMPONENT macro is evaluated, the first instance will be found and returned. Note that because these macros may declare variables, they cannot be defined twice in the same C scope.</p><p>## Error handling</p><p>As a result of the idempotent design of many operations, the API has a very small error surface. There are essentially two conditions under which an operation is unable to fulfill its postcondition:</p><p>The application provides invalid inputs to an operation</p><p>The operating system is unable to fulfill a request, like a failure to allocate memory</p><p>When either of those conditions occur, the library will throw an assertion in debug mode (the source is not compiled with NDEBUG). Except for errors caused by the OS, errors are almost always caused by the invocation of a single operation, which makes applications easy to debug.</p><p>This approach has several advantages. Application code does not need to check for errors. If an error occurs, the assertion will cause application execution to halt. As a result of this, application code is cleaner and more robust, as it is impossible to forget to handle an error condition.</p><p>## Memory ownership</p><p>Most of the API is handle based, as many API constructs are implemented using entities. There are a few instances where an application will interface with memory managed by the framework, or when an application needs to provide memory it manages to the API. In these scenarios there are four rules:</p><p>If an operation accepts a const T*, the application retains ownership of the memory</p><p>If an operation accepts a T*, ownership is transferred from application to framework</p><p>If an operation returns a const T*, the framework retains ownership of the memory</p><p>If an operation returns a T*, ownership is transferred from framework to application</p><p>The ecs_get_name operation is an example where the framework retains ownership:</p><p>const char *name = ecs_get_name(world, e);</p><p>ecs_get_nameconst char * ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)Get the name of an entity.</p><p>The ecs_get_fullpath operation is an example where the ownership is transferred to the application:</p><p>char *path = ecs_get_fullpath(world, e);</p><p>Memory for which ownership has been transferred to the application will need to be freed by the application. This should be done by the ecs_os_free operation:</p><p>ecs_os_free(path);</p><p>## Entity names</p><p>An application can assign names to entities. Names can be assigned at entity creation, with the ecs_entity_init function:</p><p>ecs_entity_t e = ecs_entity(world, { .name = "MyEntity" });</p><p>ecs_entity#define ecs_entity(world,...)Shorthand for creating an entity with ecs_entity_init.Definition: flecs_c.h:166</p><p>Alternatively, names can be assigned afterwards with the ecs_set_name function:</p><p>ecs_set_name(world, e, "MyEntity");</p><p>ecs_set_nameecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)Set the name of an entity.</p><p>The ecs_set_name function may be used as a shortcut to create a new named entity by providing 0 for the entity argument:</p><p>ecs_entity_t e = ecs_set_name(world, 0, "MyEntity");</p><p>The name of an entity can be retrieved with the ecs_get_name function:</p><p>printf("Name = %s\n", ecs_get_name(world, e));</p><p>The entity name is stored in (EcsIdentifier, EcsName). Alternatively, the name can be retrieved with ecs_get_pair: const EcsIdentifier *ptr = ecs_get_pair(world, e, EcsIdentifier, EcsName);</p><p>printf("Name = %s\n", ptr->value);</p><p>EcsNameconst ecs_entity_t EcsNameTag to indicate name identifier.</p><p>EcsIdentifierA (string) identifier.Definition: flecs.h:1086</p><p>EcsIdentifier::valuechar * valueIdentifier string.Definition: flecs.h:1087</p><p>Names can be used to lookup entities:</p><p>ecs_entity_t e = ecs_lookup(world, "MyEntity");</p><p>ecs_lookupecs_entity_t ecs_lookup(const ecs_world_t *world, const char *name)Lookup an entity by name.</p><p>When an entity is part of a hierarchy, names can be used to form a path:</p><p>ecs_entity_t parent = ecs_new_id(world);</p><p>ecs_entity_t child = ecs_new_w_pair(world, EcsChildOf, parent);</p><p>ecs_entity_t grandchild = ecs_new_w_pair(world, EcsChildOf, child);</p><p>ecs_set_name(world, parent, "Parent");</p><p>ecs_set_name(world, child, "Child");</p><p>ecs_set_name(world, grandchild, "GrandChild");</p><p>char *path = ecs_get_fullpath(world, grandchild);</p><p>printf("Path = %s\n", path); // prints Parent.Child.GrandChild</p><p>ecs_os_free(path);</p><p>EcsChildOfconst ecs_entity_t EcsChildOfUsed to express parent-child relationships.</p><p>ecs_new_idecs_entity_t ecs_new_id(ecs_world_t *world)Create new entity id.</p><p>A path can be created relative to a parent:</p><p>char *path = ecs_get_path(world, parent, grandchild);</p><p>printf("Path = %s\n", path); // prints Child.GrandChild</p><p>ecs_os_free(path);</p><p>Paths can be used to lookup an entity:</p><p>ecs_entity_t e = ecs_lookup_fullpath(world, "Parent.Child.GrandChild");</p><p>Path lookups may be relative:</p><p>ecs_entity_t e = ecs_lookup_path(world, parent, "Child.GrandChild");</p><p>## Macros</p><p style="background-color:lightgreen">The C99 API heavily relies on function-style macros, probably more than you would see in other libraries. The number one reason for this is that an ECS framework needs to work with user-defined types, and C does not provide out of the box support for generics. A few strategies have been employed in the API to improve its overall ergonomics, type safety and readability. Let's start with a simple example:</p><p style="background-color:lightgreen">typedef struct Position {</p><p style="background-color:lightgreen">float x;</p><p style="background-color:lightgreen">float y;</p><p style="background-color:lightgreen">} Position;</p><p style="background-color:lightgreen">ECS_COMPONENT(world, Position);</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_new(world, Position);</p><p style="background-color:lightgreen">From a readability perspective this code looks fine as we can easily tell what is happening here. Though if we take a closer look, we can see that a typename is used where we expect an expression, and that is not possible in plain C. So what is going on?</p><p style="background-color:lightgreen">Let's first remove the ECS_COMPONENT macro and replace it with equivalent code (details are omitted for brevity):</p><p style="background-color:lightgreen">ecs_entity_t ecs_id(Position) = ecs_component_init(world, &(ecs_component_desc_t){</p><p style="background-color:lightgreen">.entity.name = "Position",</p><p style="background-color:lightgreen">.size = sizeof(Position),</p><p style="background-color:lightgreen">.alignment = ECS_ALIGNOF(Position)</p><p style="background-color:lightgreen">});</p><p style="background-color:lightgreen">ecs_component_initecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)Find or create a component.</p><p style="background-color:lightgreen">ecs_component_desc_tUsed with ecs_component_init.Definition: flecs.h:835</p><p style="background-color:lightgreen">The first line actually registers the component with Flecs, and captures its name and size. The result is stored in a variable with name ecs_id(Position). Here, ecs_id is a macro that translates the typename of the component to a variable name. The actual name of the variable is:</p><p style="background-color:lightgreen">FLECS__EPosition</p><p style="background-color:lightgreen">ECS operations that accept a typename, such as ecs_get will look for the FLECS__E variable: Position *p = ecs_get(world, e, Position);</p><p style="background-color:lightgreen">Translates into:</p><p style="background-color:lightgreen">Position *p = (Position*)ecs_get_id(world, e, ecs_id(Position));</p><p style="background-color:lightgreen">ecs_get_idconst void * ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)Get an immutable pointer to a component.</p><p style="background-color:lightgreen">As you can see, the ecs_get macro casts the result of the function to the correct type, so a compiler will throw a warning when an application tries to assign the result of the operation to a variable of the wrong type.</p><p style="background-color:lightgreen">Similarly, ecs_set is a macro that ensures that anything we pass into it is of the right type:</p><p style="background-color:lightgreen">ecs_set(world, e, Position, {10, 20});</p><p style="background-color:lightgreen">Translates into:</p><p style="background-color:lightgreen">ecs_set_id</p><p style="background-color:lightgreen">(world, e, ecs_id(Position), sizeof(Position),</p><p style="background-color:lightgreen">&(Position){10, 20});</p><p style="background-color:lightgreen">ecs_set_idecs_entity_t ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, size_t size, const void *ptr)Set the value of a component.</p><p>In addition to casting the value to the right type and passing in the component, this macro also captures the size of the type, which saves Flecs from having to do a component data lookup.</p><p>Understanding how the macros work will go a long way in being able to write effective code in Flecs, and will lead to less surprises when debugging the code.</p><p style="background-color:lightgreen"># Entities</p><p style="background-color:lightgreen"># Entities are uniquely identifiable objects in a game or simulation. In a real time strategy game, there may be entities for the different units, buildings, UI elements and particle effects, but also for example the camera, world and player. An entity does not contain any state, and is not of a particular type. In a traditional OOP-based game, you may expect a tank in the game is of class "Tank". In ECS, an entity is simply a unique identifier, and any data and behavior associated with that entity is implemented with components and systems.</p><p style="background-color:lightgreen">In Flecs, an entity is represented by a 64 bit integer, which is also how it is exposed on the API:</p><p>typedef uint64_t ecs_entity_t;</p><p>Zero indicates an invalid entity. Applications can create new entities with the ecs_new operation:</p><p>ecs_entity_t e = ecs_new(world, 0);</p><p>This operation guarantees to return an unused entity identifier. The first entity returned is not 1, as Flecs creates a number of builtin entities during the initialization of the world. The identifier of the first returned entity is stored in the EcsFirstUserEntityId constant.</p><p>## Id recycling</p><p>Entity identifiers are reused when deleted. The ecs_new operation will first attempt to recycle a deleted identifier before producing a new one. If no identifier can be recycled, it will return the last issued identifier + 1.</p><p>Entity identifiers can only be recycled if they have been deleted with ecs_delete. When ecs_delete is invoked, the generation count of the entity is increased. The generation is encoded in the entity identifier, which means that any existing entity identifiers with the old generation encoded in it will be considered not alive. Calling a delete multiple times on an entity that is not alive has no effect.</p><p>When using multiple threads, the ecs_new operation guarantees that the returned identifiers are unique, by using atomic increments instead of a simple increment operation. New ids generated from a thread will not be recycled ids, since this would require taking a lock on the administration. While this does not represent a memory leak, it could cause ids to rise over time. If this happens and is an issue, an application should pre-create the ids.</p><p>## Generations</p><p>When an entity is deleted, the generation count for that entity id is increased. The entity generation count enables an application to test whether an entity is still alive or whether it has been deleted, even after the id has been recycled. Consider:</p><p>ecs_entity_t e = ecs_new(world, 0);</p><p>ecs_delete(world, e); // Increases generation</p><p>e = ecs_new(world, 0); // Recycles id, but with new generation</p><p>ecs_deletevoid ecs_delete(ecs_world_t *world, ecs_entity_t entity)Delete an entity.</p><p>The generation is encoded in the entity id, which means that even though the base id is the same in the above example, the value returned by the second ecs_new is different than the first.</p><p>To test whether an entity is alive, an application can use the ecs_is_alive call:</p><p>ecs_entity_t e1 = ecs_new(world, 0);</p><p>ecs_delete(world, e1);</p><p>ecs_entity_t e2 = ecs_new(world, 0);</p><p>ecs_is_alive(world, e1); // false</p><p>ecs_is_alive(world, e2); // true</p><p>ecs_is_alivebool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)Test whether an entity is alive.</p><p>It is not allowed to invoke operations on an entity that is not alive, and doing so may result in an assert. The only operation that is allowed on an entity that is not alive is ecs_delete. Calling delete multiple times on an entity that is not alive will not increase the generation. Additionally, it is also not allowed to add child entities to an entity that is not alive. This will also result in an assert.</p><p>There are 16 bits reserved for generation in the entity id, which means that an application can delete the same id 65536 times before the generation resets to 0. To get the current generation of an entity, applications can use the ECS_GENERATION macro. To extract the entity id without the generation, an application can apply the ECS_ENTITY_MASK with a bitwise and:</p><p>ecs_entity_t generation = ECS_GENERATION(e);</p><p>ecs_entity_t id = e & ECS_ENTITY_MASK;</p><p>## Manual id generation</p><p>Applications do not have to rely on ecs_new and ecs_delete to create and delete entity identifiers. Entity ids may be used directly, like in this example:</p><p>ecs_add(world, 42, Position);</p><p>This is particularly useful when the lifecycle of an entity is managed by another data source (like a multiplayer server) and prevents networking code from having to check whether the entity exists. This also allows applications to reuse existing identifiers, as long as these fit inside a 64 bit integer.</p><p>When not using manual ids, id recycling mechanisms are bypassed as these are only invoked by the ecs_new and ecs_delete operations. Combining manual ids with ecs_new and ecs_delete can result in unexpected behavior, as ecs_new may return an identifier that an application has already used.</p><p>## Id ranges</p><p>An application can instruct Flecs to issue ids from a specific offset and up to a certain limit with the ecs_set_entity_range operation. This example ensures that id generation starts from id 5000:</p><p style="background-color:lightgreen">ecs_set_entity_range(world, 5000, 0);</p><p style="background-color:lightgreen">ecs_set_entity_rangevoid ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)Set a range for issueing new entity ids.</p><p>If the last issued id was higher than 5000, the operation will not cause the last id to be reset to 5000. An application can also specify the highest id that can be generated:</p><p>ecs_set_entity_range(world, 5000, 10000);</p><p>If invoking ecs_new would result in an id higher than 10000, the application would assert. If 0 is provided for the maximum id, no upper bound will be enforced.</p><p>It is possible for an application to enforce that entity operations (ecs_add, ecs_remove, ecs_delete) are only allowed for the configured range with the ecs_enable_range_check operation:</p><p>ecs_enable_range_check(world, true);</p><p>ecs_enable_range_checkbool ecs_enable_range_check(ecs_world_t *world, bool enable)Enable/disable range limits.</p><p>This can be useful for enforcing that an application is not modifying entities that are owned by another data source.</p><p># Types</p><p>## Basic usage</p><p>A type is typically used to describe the contents (components) of an entity. A simple example:</p><p>// Create entity with type Position</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_new(world, Position);</p><p style="background-color:lightgreen">// Add Velocity to the entity</p><p style="background-color:lightgreen">ecs_add(world, e, Velocity);</p><p>After running this code, the type can be printed:</p><p>// Print the type of the entity</p><p>const ecs_type_t *type = ecs_get_type(world, e);</p><p>char *str = ecs_type_str(world, type);</p><p>ecs_get_typeconst ecs_type_t * ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)Get the type of an entity.</p><p>ecs_type_strchar * ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)Convert type to string.</p><p>ecs_type_tAn array with (component) ids.Definition: flecs.h:285</p><p>Which will produce:</p><p>Position, Velocity</p><p>## Advanced usage</p><p>A type is stored as a vector of identifiers. Because components are stored as entities in Flecs, a type is defined as (pseudo, not actual definition):</p><p>typedef vector<ecs_entity_t> ecs_type_t;</p><p>As a result, an application is able to do this:</p><p>ecs_entity_t tag_1 = ecs_new(world, 0);</p><p>ecs_entity_t tag_2 = ecs_new(world, 0);</p><p>ecs_entity_t e = ecs_new(world, 0);</p><p>ecs_add_id(world, e, tag_1);</p><p>ecs_add_id(world, e, tag_2);</p><p>ecs_add_idvoid ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)Add a (component) id to an entity.</p><p>Printing the contents of the type of e now would produce something similar to:</p><p>256, 257</p><p>When the type contained components the names of the components were printed. This is because the component entities have a name. The following example sets the names for tag_1 and tag_2:</p><p>ecs_set_name(world, tag_1, "tag_1");</p><p>ecs_set_name(world, tag_2, "tag_2");</p><p>Printing the type again will now produce:</p><p>tag_1, tag_2</p><p># Components</p><p>A component is a plain datatype that can be attached to an entity. An entity can contain any number of components, and each component can be added only once per entity. # Components are registered with a world using the ECS_COMPONENT macro, after which they can be added and removed to and from entities. # Components can be of any datatype. The following example shows how to register and use components:</p><p>// # Components can be defined from regular types</p><p>typedef struct Position {</p><p>float x, y;</p><p>} Position;</p><p>int main() {</p><p style="background-color:lightgreen">ecs_world_t *world = ecs_init();</p><p style="background-color:lightgreen">// Register the component with the world</p><p style="background-color:lightgreen">ECS_COMPONENT(world, Position);</p><p style="background-color:lightgreen">// Create a new entity with the component</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_new(world, Position);</p><p style="background-color:lightgreen">// Remove the component from the entity</p><p style="background-color:lightgreen">ecs_remove(world, e, Position);</p><p style="background-color:lightgreen">// Add the component again</p><p style="background-color:lightgreen">ecs_add(world, e, Position);</p><p style="background-color:lightgreen">}</p><p style="background-color:lightgreen">Component values can be set with the ecs_set operation. If the entity did not yet have the component, it will be added:</p><p style="background-color:lightgreen">ecs_set(world, e, Position, {10, 20});</p><p style="background-color:lightgreen">Applications can get the value of a component with the ecs_get function:</p><p style="background-color:lightgreen">The value of a component can be requested with ecs_get, which will return NULL if the entity does not have the component:</p><p style="background-color:lightgreen">const Position *p = ecs_get(world, e, Position);</p><p style="background-color:lightgreen">The ecs_get operation returns a const pointer which should not be modified by the application. An application can obtain a mutable pointer with ecs_get_mut. The ecs_get_mut operation ensures that, even when using multiple threads, an application obtains a pointer to a component that can be safely modified, whereas the ecs_get operation might return a pointer to memory that is shared between threads. When an application modified a component obtained with ecs_get_mut, it should invoke ecs_modified to let the framework know the component value was changed. An example:</p><p style="background-color:lightgreen">Position *p = ecs_get_mut(world, e, Position);</p><p style="background-color:lightgreen">p->x++;</p><p style="background-color:lightgreen">ecs_modified(world, e, Position);</p><p style="background-color:lightgreen">## Component handles</p><p>In order to be able to add, remove and set components on an entity, the API needs access to the component handle. A component handle uniquely identifies a component and is passed to API functions. There are two types of handles that are accepted by API functions, a type handle and an entity handle. These handles are automatically defined as variables by the ECS_COMPONENT macro. If an application wants to use the component in another scope, the handle will have to be either declared globally or passed to that scope explicitly.</p><p>### Global component handles</p><p>To globally declare a component, an application can use the ECS_COMPONENT_DECLARE and ECS_COMPONENT_DEFINE macros:</p><p>// Declare component variable in the global scope</p><p>ECS_COMPONENT_DECLARE(Position);</p><p>// Function that uses the global component variable</p><p>ecs_entity_t create_entity(ecs_world_t *world) {</p><p>return ecs_new(world, Position);</p><p>}</p><p>int main(int argc, char *argv[]) {</p><p>ecs_world_t *world = ecs_init();</p><p>// Register component, assign id to the global component variable</p><p>ECS_COMPONENT_DEFINE(world, Position);</p><p>ecs_entity_t e = create_entity(world);</p><p>return ecs_fini(world);</p><p>}</p><p>ECS_COMPONENT_DEFINE#define ECS_COMPONENT_DEFINE(world, id_)Define a forward declared component.Definition: flecs_c.h:100</p><p>ECS_COMPONENT_DECLARE#define ECS_COMPONENT_DECLARE(id)Forward declare a component.Definition: flecs_c.h:93</p><p>To make a component available for other source files, an application can use the regular extern keyword:</p><p>extern ECS_COMPONENT_DECLARE(Position);</p><p>Declaring components globally works with multiple worlds, as the second time a component is registered it will use the same id. There is one caveat: an application should not define a component in world 2 that is not defined in world 1 before defining the shared components. The reason for this is that if world 2 does not know that the shared component exists, it may assign its id to another component, which can cause a conflict.</p><p>If this is something you cannot guarantee in an application, a better (though more verbose) way is to use local component handles.</p><p>### Local component handles</p><p>When an application cannot declare component handles globally, it can pass component handles manually. Manually passing component handles takes the variables that are declared by the ECS_COMPONENT macro and passes them to other functions. This section describes how to pass those handles around.</p><p>Some operations can process multiple components in a single operation, like ecs_add and ecs_remove. Such operations require a handle of ecs_type_t. The ECS_COMPONENT macro defines a variable of ecs_type_t that contains only the id of the component. The variable defined by ECS_COMPONENT can be accessed with ecs_type(ComponentName). This escapes the component name, which is necessary as it would otherwise conflict with the C type name. The following example shows how to pass a type handle to another function:</p><p>typedef struct Position {</p><p>float x, y;</p><p>} Position;</p><p>void new_w_position(ecs_world_t *t, ecs_id_t ecs_id(Position)) {</p><p>// ecs_new uses an ecs_id_t</p><p>ecs_new(world, Position);</p><p>}</p><p>int main() {</p><p>ecs_world_t *world = ecs_init();</p><p>ECS_COMPONENT(world, Position);</p><p>new_w_position(world, ecs_id(Position));</p><p>ecs_fini(world);</p><p>}</p><p>ecs_id_tuint64_t ecs_id_tAn id.Definition: flecs.h:279</p><p>The ecs_new, ecs_add and ecs_remove (not exhaustive) functions are wrapper macros around functions functions that accept a component id. The following code is equivalent to the previous example:</p><p>typedef struct Position {</p><p>float x, y;</p><p>} Position;</p><p>void new_w_position(ecs_world_t *t, ecs_id_t p_id) {</p><p>// Use plain variable name with the ecs_new_w_id operation</p><p>ecs_new_w_id(world, p_id);</p><p>}</p><p>int main() {</p><p>ecs_world_t *world = ecs_init();</p><p>ECS_COMPONENT(world, Position);</p><p>new_w_position(world, ecs_id(Position));</p><p>ecs_fini(world);</p><p>}</p><p>ecs_new_w_idecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t id)Create new entity with (component) id.</p><p>## Component disabling</p><p># Components can be disabled, which prevents them from being matched with queries. Contrary to removing a component, disabling a component does not remove it from an entity. When a component is enabled after disabling it, the original value of the component is restored.</p><p>To enable or disable a component, use the ecs_enable_component function:</p><p>typedef struct Position {</p><p>float x, y;</p><p>} Position;</p><p>int main() {</p><p>ecs_world_t *world = ecs_init();</p><p>ECS_COMPONENT(world, Position);</p><p>ecs_entity_t e = ecs_new(world, Position);</p><p>/* Component is enabled by default */</p><p>/* Disable the component */</p><p>ecs_enable_component(world, e, Position, false);</p><p>/* Will return false */</p><p>printf("%d\n", ecs_is_enabled_component(world, e, Position));</p><p>/* Re-enable the component */</p><p>ecs_enable_component(world, e, Position, true);</p><p>ecs_fini(world);</p><p>}</p><p style="background-color:lightgreen">## Component disabling works by maintaining a bitset alongside the component array. When a component is enabled or disabled, the bit that corresponds with the entity is set to 1 or 0. Bitsets are not created by default. Only after invoking the ecs_enable_component operation for an entity will be entity be moved to a table that keeps track of a bitset for that component.</p><p style="background-color:lightgreen">When a query is matched with a table that has a bitset for a component, it will automatically use the bitset to skip disabled values. If an entity contains multiple components tracked by a bitset, the query will evaluate each bitset and only yield entities for which all components are enabled. To ensure optimal performance, the query will always return the largest range of enabled components. Nonetheless, iterating a table with a bitset is slower than a regular table.</p><p style="background-color:lightgreen">If a query is matched with a table that has one or more bitsets, but the query does not match with components tracked by a bitset, there is no performance penalty.</p><p style="background-color:lightgreen">## Component disabling can be used to temporarily suspend and resume a component value. It can also be used as a faster alternative to ecs_add/ecs_remove. Since the operation only needs to set a bit, it is a significantly faster alternative to adding/removing components, at the cost of a slightly slower iteration speed. If a component needs to be added or removed frequently, enabling/disabling is recommended.</p><p style="background-color:lightgreen">### Limitations</p><p style="background-color:lightgreen">## Component disabling does not work for components not matched with the entity. If a query matches with a component from a base (prefab) or parent entity and the component is disabled for that entity, the query will not take this into account. If entities with disabled components from a base or parent entity need to be skipped. a query should manually check this.</p><p style="background-color:lightgreen">Because component disabling is implemented with a type role, it cannot be used together with other type roles. This means that it is not possible to disable, for example, tags with SWITCH or CASE roles. Additionally since relationships rely on a role, it is currently not possible to disable relationships such as (ChildOf, parent) or (IsA, prefab).</p><p>Another limitation is that currently the query NOT (!) operator does not take into account disabled entities. The optional operator (?) technically works, but a query is unable to see whether a component has been set or not as both the enabled and disabled values are returned to the application in a single array.</p><p style="background-color:lightgreen"># Tagging</p><p>Tags are much like components, but they are not associated with a data type. Tags are typically used to add a flag to an entity, for example to indicate that an entity is an Enemy:</p><p>int main() {</p><p>ecs_world_t *world = ecs_init();</p><p>// Register the tag with the world. There is no Enemy type</p><p>ECS_TAG(world, Enemy);</p><p>// Add the Enemy tag</p><p>ecs_add(world, e, Enemy);</p><p>// Remove the Enemy tag</p><p>ecs_remove(world, e, Enemy);</p><p>}</p><p>ECS_TAG#define ECS_TAG(world, id)Declare & define a tag.Definition: flecs_c.h:73</p><p>## Tag handles</p><p>Just like components, the API needs a handle to a tag before it can use it, and just like ECS_COMPONENT, the ECS_TAG macro defines two variables, one of type ecs_type_t and one of ecs_entity_t. Passing a handle of an ecs_type_t into a function looks similar to a component:</p><p>void new_w_tag(ecs_world_t *t, ecs_type_t ecs_type(Tag)) {</p><p>// ecs_new uses an ecs_type_t</p><p>ecs_new(world, Tag);</p><p>}</p><p>int main() {</p><p>ecs_world_t *world = ecs_init();</p><p>ECS_TAG(world, Tag);</p><p>new_w_tag(world, ecs_type(Tag));</p><p>ecs_fini(world);</p><p>}</p><p>For functions that require an ecs_entity_t handle, the tag variable names are not escaped, since they do not clash with a C type name. An example:</p><p>void add_tag(ecs_world_t *t, ecs_entity_t e, ecs_entity_t Tag) {</p><p>ecs_add_id(world, e, Tag);</p><p>}</p><p>int main() {</p><p>ecs_world_t *world = ecs_init();</p><p>ECS_TAG(world, Tag);</p><p>ecs_entity_t e = ecs_new(world, 0);</p><p>add_tag(world, e, Tag);</p><p>ecs_fini(world);</p><p>}</p><p>Anyone who paid careful attention to this example will notice that the ecs_add_id operation accepts two regular entities.</p><p># Observers</p><p># Observers are callbacks that are invoked when one or more events matches the query of an observer. Events can be either user defined or builtin. Examples of builtin events are OnAdd, OnRemove and OnSet.</p><p>When an observer has a query with more than one component, the observer will not match until the entity for which the event is emitted satisfies the entire query.</p><p>An example of an observer with a single component:</p><p>ECS_OBSERVER(world, AddPosition, EcsOnAdd, Position);</p><p>EcsOnAddconst ecs_entity_t EcsOnAddEvent.</p><p>ECS_OBSERVER#define ECS_OBSERVER(world, id, kind,...)Declare & define an observer.Definition: flecs_c.h:152</p><p>The implementation of the observer looks similar to a system:</p><p>void AddPosition(ecs_iter_t *it) {</p><p>Position *p = ecs_field(it, Position, 1);</p><p>for (int i = 0; i < it->count; i++) {</p><p>p[i].x = 10;</p><p>p[i].y = 20;</p><p>printf("Position added\n");</p><p>}</p><p>}</p><p># Modules</p><p># Modules allow an application to split up systems and components into separate decoupled units. The purpose of modules is to make it easier to organize systems and components for large projects. Additionally, modules also make it easier to split off functionality into separate compilation units.</p><p>A module consists out of a couple parts:</p><p>The declaration of the components, tags, and systems of the module contents</p><p>An import function that loads the module contents for a world</p><p>The declaration of the module contents module is typically located in a separate module header file, and look like this for a module named "Vehicles":</p><p>typedef struct Car {</p><p>float speed;</p><p>} Car;</p><p>typedef struct Bus {</p><p>float speed;</p><p>} Bus;</p><p>typedef struct MotorCycle {</p><p>float speed;</p><p>} MotorCycle;</p><p style="background-color:lightgreen">/* # Components are declared with ECS_COMPONENT_DECLARE */</p><p style="background-color:lightgreen">extern ECS_COMPONENT_DECLARE(Car);</p><p style="background-color:lightgreen">extern ECS_COMPONENT_DECLARE(Bus);</p><p style="background-color:lightgreen">extern ECS_COMPONENT_DECLARE(MotorCycle);</p><p style="background-color:lightgreen">/* Tags are declared with ECS_DECLARE */</p><p style="background-color:lightgreen">extern ECS_DECLARE(Moving);</p><p style="background-color:lightgreen">/* Systems are declared with ECS_SYSTEM_DECLARE */</p><p style="background-color:lightgreen">extern ECS_SYSTEM_DECLARE(Move);</p><p style="background-color:lightgreen">/* Forward declaration to the import function */</p><p style="background-color:lightgreen">/* The function name has to follow the convention: <ModuleName>Import */</p><p style="background-color:lightgreen">void VehiclesImport(ecs_world_t *world);</p><p style="background-color:lightgreen">ECS_SYSTEM_DECLARE#define ECS_SYSTEM_DECLARE(id)Forward declare a system.Definition: system.h:104</p><p style="background-color:lightgreen">The import function for this module is typically located in a module source file, and would look like this:</p><p style="background-color:lightgreen">void VehiclesImport(ecs_world_t *world) {</p><p style="background-color:lightgreen">/* Define the module */</p><p style="background-color:lightgreen">ECS_MODULE(world, Vehicles);</p><p style="background-color:lightgreen">/* Declare components, tags, systems, and assign them to the module with their respective _DEFINE macros */</p><p style="background-color:lightgreen">ECS_COMPONENT_DEFINE(world, Car);</p><p style="background-color:lightgreen">ECS_COMPONENT_DEFINE(world, Bus);</p><p style="background-color:lightgreen">ECS_COMPONENT_DEFINE(world, MotorCycle);</p><p style="background-color:lightgreen">ECS_TAG_DEFINE(world, Moving);</p><p style="background-color:lightgreen">ECS_SYSTEM_DEFINE(world, Move, EcsOnUpdate, Car, Moving);</p><p style="background-color:lightgreen">}</p><p style="background-color:lightgreen">ECS_SYSTEM_DEFINE#define ECS_SYSTEM_DEFINE(world, id_, phase,...)Define a forward declared system.Definition: system.h:111</p><p style="background-color:lightgreen">ECS_TAG_DEFINE#define ECS_TAG_DEFINE(world, id)Define a forward declared tag.Definition: flecs_c.h:66</p><p style="background-color:lightgreen">After the module has been defined, it can be imported in an application like this:</p><p style="background-color:lightgreen">ecs_world_t *world = ecs_init();</p><p style="background-color:lightgreen">/* Import module, which invokes the module import function */</p><p style="background-color:lightgreen">ECS_IMPORT(world, Vehicles);</p><p style="background-color:lightgreen">/* The module contents can now be used */</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_new(world, Car);</p><p>Module contents are namespaced, which means that the identifiers of the content of the module (components, tags, systems) are stored in the scope of the module. For the above example module, everything would be stored in the vehicles scope. To resolve the Car component by name, an application would have to do:</p><p>ecs_entity_t car_entity = ecs_lookup_fullpath(world, "vehicles.Car");</p><p>Note that even though the module name is specified with uppercase, the name is stored with lowercase. This is because the naming convention for modules in C is PascalCase, whereas the stored identifiers use snake_case. If a module name contains several uppercase letters, this will be translated to a nested module. For example, the C module name MySimpleModule will be translated to my.simple.module.</p><p># ## Modules in C++</p><p>A module in C++ is defined as a class where the module contents are defined in the constructor. The above Vehicles module would look like this in C++:</p><p>/* In C++ it is more convenient to define tags as empty structs */</p><p>struct Moving { };</p><p>/* Module implementation */</p><p>class vehicles {</p><p>public:</p><p>vehicles(flecs::world& world) {</p><p>flecs::module<Vehicles>(world, "vehicles");</p><p>m_car = flecs::component<Car>(world, "Car");</p><p>m_bus = flecs::component<Bus>(world, "Bus");</p><p>m_motor_cycle = flecs::component<MotorCycle>(world, "MotorCycle");</p><p>m_moving = flecs::component<Moving>(world, "Moving");</p><p>m_move = flecs::system<Car, Moving>(world, "Move")</p><p>.each([](flecs::entity e, Car &car, Moving&) {</p><p>/* System implementation */</p><p>});</p><p>}</p><p>flecs::entity m_car;</p><p>flecs::entity m_bus;</p><p>flecs::entity m_motor_cycle;</p><p>flecs::entity m_moving;</p><p>flecs::entity m_move;</p><p>}</p><p>flecs::componentComponent class.Definition: component.hpp:348</p><p>flecs::entity_view::eachvoid each(const Func &func) constIterate (component) ids of an entity.Definition: impl.hpp:117</p><p>flecs::entityEntity.Definition: entity.hpp:30</p><p>flecs::systemDefinition: impl.hpp:68</p><p>flecs::worldThe world.Definition: world.hpp:113</p><p>An application can import the module in C++ like this:</p><p style="background-color:lightgreen">flecs::world world;</p><p style="background-color:lightgreen">flecs::import<vehicles>(world);</p><p style="background-color:lightgreen"># Hierarchies</p><p># Entities in Flecs can be organized in hierarchies, which is useful when for example constructing a scene graph. To create hierarchies, applications can add ChildOf relationships to entities. This creates a relationship between a parent entity and a child entity that the application can later traverse. This is an example of a simple hierarchy:</p><p>ecs_entity_t parent = ecs_new(world, 0);</p><p>ecs_entity_t child = ecs_new_w_pair(world, EcsChildOf, parent);</p><p>ChildOf relationships can be added and removed dynamically, similar to how components can be added and removed:</p><p>ecs_add_pair(world, child, EcsChildOf, parent);</p><p>ecs_remove_pair(world, child, EcsChildOf, parent);</p><p>ChildOf relationships can also be created through the ECS_ENTITY macro:</p><p>ECS_ENTITY(world, parent, 0);</p><p>ECS_ENTITY(world, child, (ChildOf, parent));</p><p>ECS_ENTITY#define ECS_ENTITY(world, id,...)Declare & define an entity.Definition: flecs_c.h:53</p><p>## Iteration</p><p>Applications can iterate hierarchies depth first with the ecs_children API in C, and the children() iterator in C++. This example shows how to iterate all the children of an entity:</p><p>In C: ecs_iter_t it = ecs_children(world, parent);</p><p>while(ecs_children_next(&it)) {</p><p>for (int i = 0; i < it.count; i++) {</p><p>ecs_entity_t child = it.entities[i];</p><p>char *path = ecs_get_fullpath(world, child);</p><p>printf("%s\n", path);</p><p>free(path);</p><p>}</p><p>}</p><p>ecs_children_nextbool ecs_children_next(ecs_iter_t *it)Progress a children iterator.</p><p>ecs_childrenecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)Iterator for a parent's children.</p><p>In C++: e.children([&](flecs::entity child) {</p><p>std::cout << child.path() << std::endl;</p><p>});</p><p>flecs::entity_view::pathflecs::string path(const char *sep="::", const char *init_sep="::") constReturn the entity path.Definition: entity_view.hpp:94</p><p>## Hierarchical queries</p><p>Queries and systems can request data from parents of the entity being iterated over with the parent modifier:</p><p>// Iterate all entities with Position that have a parent that also has Position</p><p>ecs_query_t *q = ecs_query_new(world, "Position(parent), Position");</p><p>ecs_query_tstruct ecs_query_t ecs_query_tA query allows for cached iteration over ECS data.Definition: flecs.h:300</p><p>Additionally, a query can iterate the hierarchy in breadth-first order by providing the cascade modifier:</p><p>// Iterate all entities with Position that have a parent that also has Position</p><p>ecs_query_t *q = ecs_query_new(world, "Position(parent|cascade), Position");</p><p style="background-color:lightgreen">This does two things. First, it will iterate over all entities that have Position and that optionally have a parent that has Position. By making the parent component optional, it is ensured that if an application is iterating a tree of entities, the root is also included. Secondly, the query iterates over the children in breadth-first order. This is particularly useful when writing transform systems, as they require parent entities to be transformed before child entities.</p><p style="background-color:lightgreen">The above query does not match root entities, as they do not have a parent with Position. To also match root entities, add ? to make the term optional:</p><p style="background-color:lightgreen">ecs_query_t *q = ecs_query_new(world, "?Position(parent|cascade), Position");</p><p style="background-color:lightgreen">See the query manual section for more details.</p><p style="background-color:lightgreen">## Path identifiers</p><p style="background-color:lightgreen">When entities in a hierarchy have names assigned to them, they can be looked up with path expressions. A path expression is a list of entity names, separated by a scope separator character (by default a ., and :: in the C++ API). This example shows how to request the path expression from an entity:</p><p style="background-color:lightgreen">ECS_ENTITY(world, parent, 0);</p><p style="background-color:lightgreen">ECS_ENTITY(world, child, (ChildOf, parent));</p><p style="background-color:lightgreen">char *path = ecs_get_fullpath(world, child);</p><p style="background-color:lightgreen">printf("%s\n", path); // Prints  "parent.child"</p><p style="background-color:lightgreen">free(path);</p><p style="background-color:lightgreen">To lookup an entity using a path, use ecs_lookup_fullpath:</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_lookup_fullpath(world, "parent.child");</p><p style="background-color:lightgreen">Applications can also lookup entities using a relative path expression:</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_lookup_path(world, parent, "child.grand_child");</p><p style="background-color:lightgreen">Additionally, applications can specify a custom path separator when looking up or requesting paths:</p><p style="background-color:lightgreen">// Lookup child::grand_child relative to parent</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_lookup_path_w_sep(</p><p style="background-color:lightgreen">world, parent, "child::grand_child", "::", "::");</p><p style="background-color:lightgreen">// Get path of child relative to parent</p><p style="background-color:lightgreen">char *path = ecs_get_path_w_sep(world, parent, child, "::", "::");</p><p style="background-color:lightgreen">ecs_get_path_w_sepchar * ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)Get a path identifier for an entity.</p><p style="background-color:lightgreen">ecs_lookup_path_w_sepecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, bool recursive)Lookup an entity from a path.</p><p style="background-color:lightgreen">Note that the path separator is provided twice, once for the prefix and once for the separator. This lets the API correctly handle expressions like ::parent::child::grand_child.</p><p style="background-color:lightgreen">## Scoping</p><p style="background-color:lightgreen">Applications can set a default scope with the ecs_set_scope function, so that all operations are evaluated relative to a scope. The scope is set on a stage, which makes it thread safe when executed from within a flecs worker thread. This example shows how to set the scope:</p><p style="background-color:lightgreen">ecs_entity_t parent = ecs_new(world, 0);</p><p style="background-color:lightgreen">// Set the current scope to the parent</p><p style="background-color:lightgreen">ecs_entity_t prev_scope = ecs_set_scope(world, parent);</p><p style="background-color:lightgreen">// This entity is created as child of parent</p><p style="background-color:lightgreen">ecs_entity_t child = ecs_new(world, 0);</p><p style="background-color:lightgreen">// Look for "child" relative to parent</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_lookup_fullpath(world, "child");</p><p style="background-color:lightgreen">// It's good practice to restore the previous scope</p><p style="background-color:lightgreen">ecs_set_scope(prev_scope);</p><p style="background-color:lightgreen">ecs_set_scopeecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)Set the current scope.</p><p># Modules automatically set the scope to the module itself, so that the module acts as a namespace for its contents.</p><p>## Paths and signatures</p><p>When referencing entities or components in a signature or type expression that are not stored in the root, an application will have to provide the path. Signatures and type expressions always use the dot (.) as separator. For example, if a component "Position" is defined in the module "transform", a system subscribing for the component would have to be defined like this:</p><p>ECS_SYSTEM(world, Move, EcsOnUpdate, transform.Position);</p><p>The same goes for other parts of the API that accept a type expression, like ECS_ENTITY:</p><p>ECS_ENTITY(world, Movable, transform.Position);</p><p>If the system would be defined in the same scope as the Position component, it would not need to specify the path:</p><p>ECS_ENTITY(world, transform, 0);</p><p>ecs_entity_t prev_scope = ecs_set_scope(world, transform);</p><p>ECS_COMPONENT(world, Position);</p><p>// System is in the same scope, no need to add "transform"</p><p>ECS_SYSTEM(world, MoveInScope, EcsOnUpdate, Position);</p><p>ecs_set_scope(world, prev_scope);</p><p>// This system is not in the same scope, and needs to add transform</p><p>ECS_SYSTEM(world, MoveNotInScope, EcsOnUpdate, transform.Position);</p><p># Inheritance</p><p># Inheritance is the ability to share components between entities by inheriting from them, by using the IsA relationship. This is a simple example in the C API:</p><p>// Create a base entity</p><p>ecs_entity_t base = ecs_new(world, 0);</p><p>ecs_set(world, base, Position, {10, 20});</p><p>// Derive from base</p><p>ecs_entity_t e = ecs_new_w_pair(world, EcsIsA, base);</p><p>// e now shares Position with base</p><p>ecs_get(world, base, Position) == ecs_get(world, e, Position); // 1</p><p>EcsIsAconst ecs_entity_t EcsIsAUsed to express inheritance relationships.</p><p>IsA relationships can be added and removed dynamically, similar to how components can be added and removed:</p><p>ecs_add_id(world, e, (IsA, base));</p><p>ecs_remove_id(world, e, (IsA, base));</p><p>ecs_remove_idvoid ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)Remove a (component) id from an entity.</p><p>IsA relationships can also be created through the ECS_ENTITY macro:</p><p>ECS_ENTITY(world, base, Position);</p><p>ECS_ENTITY(world, e, (IsA, base));</p><p style="background-color:lightgreen">IsA relationships can be nested:</p><p style="background-color:lightgreen">ecs_entity_t base = ecs_new(world, 0);</p><p style="background-color:lightgreen">ecs_set(world, base, Position, {10, 20});</p><p style="background-color:lightgreen">ecs_entity_t derived = ecs_new_w_pair(world, EcsIsA, base);</p><p style="background-color:lightgreen">// Derive from "derived" which is itself derived from base</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_new_w_pair(world, EcsIsA, derived);</p><p>// All three entities now share Position</p><p style="background-color:lightgreen">ecs_get(world, base, Position) == ecs_get(world, e, Position); // 1</p><p style="background-color:lightgreen">ecs_get(world, base, Position) == ecs_get(world, derived, Position);  // 1</p><p style="background-color:lightgreen">## Overriding</p><p>Derived entities can override components from their base by adding the component as they would normally. When overriding a component, the value of the base component is copied to the entity. This example shows how a derived entity overrides the Position component:</p><p style="background-color:lightgreen">// Shortcut for creating a base entity and setting Position</p><p style="background-color:lightgreen">ecs_entity_t base = ecs_set(world, 0, Position, {10, 20});</p><p style="background-color:lightgreen">// Derive from the base</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_new_w_pair(world, EcsIsA, base);</p><p style="background-color:lightgreen">// Override Position</p><p style="background-color:lightgreen">ecs_add(world, e, Position);</p><p style="background-color:lightgreen">// Position component no longer matches with base</p><p style="background-color:lightgreen">ecs_get(world, base, Position) != ecs_get(world, e, Position); // 1</p><p style="background-color:lightgreen">// Prints {10, 20}</p><p style="background-color:lightgreen">const Position *p = ecs_get(world, e, Position);</p><p style="background-color:lightgreen">printf("{%f, %f}\n", p->x, p->y);</p><p style="background-color:lightgreen">When an entity shared a component from a base entity, we say that the component is "shared". If the component is not shared, it is "owned". After an entity overrides a component, it will own the component.</p><p style="background-color:lightgreen">It is possible to remove an override, in which case the component will be shared with the base entity again:</p><p style="background-color:lightgreen">// Removes override on Position</p><p style="background-color:lightgreen">ecs_remove(world, e, Position);</p><p>// Position is again shared with base</p><p>ecs_get(world, base, Position) == ecs_get(world, e, Position); // 1</p><p>Overrides work with nested IsA relationships:</p><p>// Shortcut for creating a base entity and setting Position</p><p>ecs_entity_t base = ecs_new(world, 0);</p><p>ecs_set(world, base, Position, {10, 20});</p><p>ecs_set(world, base, Velocity, {1, 1});</p><p>// Create derived entity, override Position</p><p>ecs_entity_t derived = ecs_new_w_pair(world, EcsIsA, base);</p><p>ecs_add(world, base, Position);</p><p>// Derive from 'derived', which is derived from base</p><p>ecs_entity_t e = ecs_new_w_pair(world, EcsIsA, derived);</p><p>// The entity now shares Position from derived, and Velocity from base</p><p>## Automatic overriding</p><p>In some scenarios it is desirable that an entity is initialized with a specific set of values, yet does not share the components from the base entity. In this case the derived entity can override each component individually, but this can become hard to maintain as components are added or removed to the base. This can be achieved by marking components as owned. Consider the following example:</p><p>// Create a base. Simply deriving the base will share the component, but not override it.</p><p>ecs_entity_t Base = ecs_set(world, 0, Position, {10, 20});</p><p>// Mark as OVERRIDE. This ensures that when base is derived from, Position is overridden</p><p>ecs_add_id(world, world, Base, ECS_OVERRIDE | ecs_id(Position));</p><p>// Create entity from BaseType. This adds the IsA relationship in addition</p><p>// to overriding Position, effectively initializing the Position component for the entity.</p><p>ecs_entity_t e = ecs_new_w_pair(world, EcsIsA, Base);</p><p>ECS_OVERRIDEconst ecs_id_t ECS_OVERRIDEAutomatically override component when it is inherited.</p><p>The combination of instancing, overriding and OVERRIDE is one of the fastest and easiest ways to create an entity with a set of initialized components. The OVERRIDE relationship can also be specified inside type expressions. The following example is equivalent to the previous one:</p><p>ECS_ENTITY(world, Base, Position, OVERRIDE | Position);</p><p>ecs_set(world, Base, Position, {10, 20});</p><p>ecs_entity_t e = ecs_new_w_pair(world, EcsIsA, Base);</p><p># ## Inheritance hierarchies</p><p>If a base entity has children, derived entities of that base entity will, when the IsA relationship is added, acquire the same set of children. Take this example:</p><p>ecs_entity_t parent = ecs_new(world, 0);</p><p>ecs_entity_t child_1 = ecs_new_w_pair(world, EcsChildOf, parent);</p><p>ecs_entity_t child_2 = ecs_new_w_pair(world, EcsChildOf, parent);</p><p>// Derive from parent, two children are added to the entity</p><p>ecs_entity_t e = ecs_new_w_pair(world, EcsIsA, parent);</p><p>The children that are copied to the entity will have exactly the same set of components as the children of the base. For example, if the base child has components Position, Velocity, the derived child will also have Position, Velocity. Furthermore, the values of the base child components will be copied to the entity child:</p><p>ecs_entity_t parent = ecs_new(world, 0);</p><p>ecs_entity_t child = ecs_new_w_pair(world, EcsChildOf, parent);</p><p>ecs_set_name(world, child, "Child"); // Give child a name, so we can look it up</p><p>ecs_set(world, child, Position, {10, 20});</p><p>// Derive from parent, two children are added to the derived entity</p><p>ecs_entity_t e = ecs_new_w_pair(world, EcsIsA, parent);</p><p>ecs_entity_t e_child = ecs_lookup_path(world, e, "Child");</p><p>const Position *p = ecs_get(world, e_child, Position);</p><p>printf("{%f, %f}\n", p->x, p->y); // Prints {10, 20}</p><p>// The components are not shared with the derived child!</p><p>ecs_get(world, child, Position) != ecs_get(world, e_child, Position); // 1</p><p>Since the children of the derived entity have the exact same components as the base children, their components are not shared. Component sharing between children is possible however, as IsA relationships are also copied over to the child of the derived entity:</p><p>ecs_entity_t parent = ecs_new(world, 0);</p><p>// Create child base from which we will share components</p><p>ecs_entity_t child_base = ecs_new(world, 0);</p><p>ecs_set(world, child_base, Position, {10, 20});</p><p>ecs_set_name(world, child, "Child");</p><p>// Create actual child that inherits from the child base</p><p>ecs_entity_t child = ecs_new_w_pair(world, EcsChildOf, parent);</p><p>ecs_add_pair(world, child, EcsIsA, child_base);</p><p>// Inherit from parent, two children are added to the entity</p><p>ecs_entity_t e = ecs_new_w_pair(world, EcsIsA, parent);</p><p>ecs_entity_t e_child = ecs_lookup_path(world, e, "Child");</p><p>// The component is now shared with the child and child_base</p><p>ecs_get(world, child, Position) == ecs_get(world, e_child, Position); // 1</p><p style="background-color:lightgreen">## Prefabs</p><p style="background-color:lightgreen">## Prefabs are entities that can be used as templates for other entities. ## Prefabs are regular entities, except that they are not matched by default with systems. To create a prefab, add the EcsPrefab tag when creating an entity:</p><p style="background-color:lightgreen">ecs_entity_t prefab = ecs_new_w_id(world, EcsPrefab);</p><p style="background-color:lightgreen">EcsPrefabconst ecs_entity_t EcsPrefabTag added to prefab entities.</p><p style="background-color:lightgreen">The EcsPrefab tag can also be added or removed dynamically:</p><p style="background-color:lightgreen">ecs_add_id(world, prefab, EcsPrefab);</p><p style="background-color:lightgreen">ecs_remove_id(world, prefab, EcsPrefab);</p><p style="background-color:lightgreen">## Prefabs can also be created with the ECS_PREFAB macro:</p><p style="background-color:lightgreen">ECS_PREFAB(world, prefab, Position, Velocity);</p><p style="background-color:lightgreen">ECS_PREFAB#define ECS_PREFAB(world, id,...)Declare & define a prefab.Definition: flecs_c.h:90</p><p style="background-color:lightgreen">To instantiate a prefab, an application can use the IsA relationship:</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_new_w_pair(world, (IsA, prefab));</p><p style="background-color:lightgreen">To ensure that entities that inherit from a prefab don't also inherit the Prefab tag (which would cause them to not get matched with systems), the Prefab tag does not propagate to derived entities. This is illustrated in the following example:</p><p style="background-color:lightgreen">ECS_PREFAB(world, prefab, Position);</p><p style="background-color:lightgreen">ecs_has(world, prefab, EcsPrefab); // true</p><p style="background-color:lightgreen">ecs_has(world, prefab, Position); // true</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_new_w_pair(world, (IsA, prefab));</p><p style="background-color:lightgreen">ecs_has(world, e, EcsPrefab); // false</p><p style="background-color:lightgreen">ecs_has(world, e, Position); // true</p><p style="background-color:lightgreen"># Deferred operations</p><p style="background-color:lightgreen">Applications can defer entity with the ecs_defer_begin and ecs_defer_end functions. This records all operations that happen inside the begin - end block, and executes them when ecs_defer_end is called. # Deferred operations are useful when an application wants to make modifications to an entity while iterating, as doing this without deferring an operation could modify the underlying data structure. An example:</p><p style="background-color:lightgreen">ecs_defer_begin(world);</p><p style="background-color:lightgreen">ecs_entity_t e = ecs_new(world, 0);</p><p style="background-color:lightgreen">ecs_add(world, e, Position);</p><p style="background-color:lightgreen">ecs_set(world, e, Velocity, {1, 1});</p><p style="background-color:lightgreen">ecs_defer_end(world);</p><p style="background-color:lightgreen">ecs_defer_endbool ecs_defer_end(ecs_world_t *world)End block of operations to defer.</p><p style="background-color:lightgreen">ecs_defer_beginbool ecs_defer_begin(ecs_world_t *world)Defer operations until end of frame.</p><p style="background-color:lightgreen">The effects of these operations will not be visible until the ecs_defer_end operation.</p><p style="background-color:lightgreen">There are a few things to keep in mind when deferring:</p><p style="background-color:lightgreen">creating a new entity will always return a new id which increases the last used id counter of the world</p><p style="background-color:lightgreen">ecs_get_mut returns a pointer initialized with the current component value, and does not take into account deferred set or get_mut operations</p><p style="background-color:lightgreen">if an operation is called on an entity which was deleted while deferred, the operation will ignored by ecs_defer_end</p><p style="background-color:lightgreen">if a child entity is created for a deleted parent while deferred, the child entity will be deleted by ecs_defer_end</p></body></html>