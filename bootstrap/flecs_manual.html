<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=11"/>
  <meta name="generator" content="Doxygen 1.9.5"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Flecs: Manual</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <link rel="icon" href="logo_small.png" />
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init()
      DoxygenAwesomeFragmentCopyButton.init()
      DoxygenAwesomeParagraphLink.init()
      DoxygenAwesomeInteractiveToc.init()
  </script>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/SanderMertens/flecs" class="github-corner" title="View source on GitHub" target="_blank">
  <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
  <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>
<style>
  .github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Flecs<span id="projectnumber">&#160;v3.2</span>
   </div>
   <div id="projectbrief">A fast entity component system (ECS) for C &amp; C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_Manual.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md116"></a>
Introduction</h1>
<p >Nobody likes to read manuals, and you should be able to get up and running with Flecs by using the quickstart, by looking at examples and by checking the documentation in the flecs header files. However, if you truly want to know how something works, or why it works that way, the manual is the right place to go. With that said, the manual is not exhaustive, and it complements the other sources of documentation.</p>
<h1><a class="anchor" id="autotoc_md117"></a>
Design Goals</h1>
<h2><a class="anchor" id="autotoc_md118"></a>
1. Performance</h2>
<p >Flecs is designed from the ground up to provide blazing fast iteration speeds in systems that can be vectorized by default, while minimizing cache misses. In addition, Flecs has a unique graph-based storage engine that allows for extremely fast add, remove and bulk operations. These features, amongst others, ensure that applications can get the most out of the underlying hardware.</p>
<h2><a class="anchor" id="autotoc_md119"></a>
2. Portability</h2>
<p >Flecs has been implemented in C99 and features an external interface that is C89 compatible to ensure it is portable to a wide range of platforms. The framework contains a flexible operating system abstraction API that enables an application to easily port the library to new platforms.</p>
<h2><a class="anchor" id="autotoc_md120"></a>
3. Reusability</h2>
<p >ECS has the potential for being a platform for the development of reusable, loosely coupled, plug and play features like input, physics and rendering. Flecs modules enable such features to be packaged in a loosely coupled way so that applications can simply import them, while guaranteeing a correct execution order. In addition, Flecs has features like time management that ensure a consistent baseline across modules.</p>
<h2><a class="anchor" id="autotoc_md121"></a>
4. Usability</h2>
<p >Flecs is designed first and foremost to be a framework that simplifies the development of games and simulations. Rather than just providing a vanilla ECS implementation, Flecs provides many features that are commonly found in game development frameworks such as hierarchies, prefabs and time management, all integrated seamlessly with the core ECS system.</p>
<h2><a class="anchor" id="autotoc_md122"></a>
5. Extensibility</h2>
<p >Flecs is used with other frameworks and game engines, and as such not all of its features are useful in each application. For that reason Flecs has a modular design, so that applications can easily remove features from the core that they do not need. Additionally, since many features are built on top of the ECS core, applications can easily extend or reimplement them.</p>
<h2><a class="anchor" id="autotoc_md123"></a>
6. Have fun!</h2>
<p >There are few things as satisfying as building games. If nothing else, Flecs has been built to enable creative visions both big and small. I'm having a lot of fun building Flecs, I hope you will have fun using it, and that your users will have fun playing your games :)</p>
<h1><a class="anchor" id="autotoc_md124"></a>
Diagrams</h1>
<h2><a class="anchor" id="autotoc_md125"></a>
High level architecture</h2>
<p >This diagram provides an overview of how entities, components, tables, queries, filters and systems are wired together. <img src="flecs-architecture-overview.png" alt="" class="inline" title="Architecture diagram"/>    </p>
<h2><a class="anchor" id="autotoc_md126"></a>
Component add flow</h2>
<p >This diagram provides an overview of the different steps that occur when adding a component to an entity. The diagram shows when component lifecycle callbacks, OnAdd triggers, OnSet systems, UnSet systems and monitors are invoked. Additionally the diagram shows how the defer mechanism is integrated with the listed Flecs operations. <img src="flecs-add-component-flow.png" alt="" class="inline" title="Component add flow"/>    </p>
<h2><a class="anchor" id="autotoc_md127"></a>
Component remove flow</h2>
<p >This diagram provides an overview of the different steps that occur when removing a component from an entity. The diagram shows when component lifecycle callbacks, OnRemove triggers, OnSet systems, UnSet systems and monitors are invoked. Additionally the diagram shows how the defer mechanism is integrated with the listed Flecs operations. <img src="flecs-remove-component-flow.png" alt="" class="inline" title="Component remove flow"/>    </p>
<h2><a class="anchor" id="autotoc_md128"></a>
Staging flow</h2>
<p >This diagram provides an overview of what happens when an application uses staging. Staging is a lockless mechanism that lets threads concurrently read &amp; perform structural changes on the store. Changes are temporarily stored in a command queue per stage, which can be merged with the store when convenient. <img src="flecs-staging-flow.png" alt="" class="inline" title="Staging flow"/>    </p>
<h1><a class="anchor" id="autotoc_md129"></a>
API design</h1>
<h2><a class="anchor" id="autotoc_md130"></a>
Naming conventions</h2>
<div class="fragment"><div class="line"><span class="comment">// Component names (&#39;Position&#39;) use PascalCase</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Position {</div>
<div class="line">    <span class="keywordtype">float</span> x;</div>
<div class="line">    <span class="keywordtype">float</span> y; <span class="comment">// Component members (&#39;y&#39;) use snake_case</span></div>
<div class="line">} Position;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Velocity {</div>
<div class="line">    <span class="keywordtype">float</span> x;</div>
<div class="line">    <span class="keywordtype">float</span> y;</div>
<div class="line">} Velocity;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// System names (&#39;Move&#39;) use PascalCase. API types use snake_case_t</span></div>
<div class="line"><span class="keywordtype">void</span> Move(ecs_iter_t *it) {</div>
<div class="line">    <span class="comment">// Functions use snake_case</span></div>
<div class="line">    Position *p = ecs_field(it, Position, 1);</div>
<div class="line">    Velocity *v = ecs_field(it, Velocity, 2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; it-&gt;count; i++) {</div>
<div class="line">        p[i].x += v[i].x;</div>
<div class="line">        p[i].y += v[i].y;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Declarative function-style macros use SCREAMING_SNAKE_CASE</span></div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Position);</div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Velocity);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Module names are PascalCase</span></div>
<div class="line">    <a class="code hl_define" href="group__c__addons__module.html#gae3c27bd0ac0793f8a9a3cada8b39f86f">ECS_IMPORT</a>(world, MyModule);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Enumeration constants (&#39;EcsOnUpdate&#39;) use PascalCase</span></div>
<div class="line">    <a class="code hl_define" href="group__c__addons__system.html#gafe627ef7c46f7fac4148a632c3192c81">ECS_SYSTEM</a>(world, Move, EcsOnUpdate, Position, Velocity);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Function wrapper macros use snake_case</span></div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Builtin entities use PascalCase</span></div>
<div class="line">    ecs_add(world, <a class="code hl_variable" href="group__builtin__tags.html#ga994fd8e95c33627306750e8c6adfd22a">EcsWorld</a>, Position);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="group__world__creation__deletion.html#gaa9134e57e2c71d2cd48f701e6673b364">ecs_fini</a>(world);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__builtin__tags_html_ga994fd8e95c33627306750e8c6adfd22a"><div class="ttname"><a href="group__builtin__tags.html#ga994fd8e95c33627306750e8c6adfd22a">EcsWorld</a></div><div class="ttdeci">const ecs_entity_t EcsWorld</div><div class="ttdoc">Entity associated with world (used for &quot;attaching&quot; components to world)</div></div>
<div class="ttc" id="agroup__c__addons__module_html_gae3c27bd0ac0793f8a9a3cada8b39f86f"><div class="ttname"><a href="group__c__addons__module.html#gae3c27bd0ac0793f8a9a3cada8b39f86f">ECS_IMPORT</a></div><div class="ttdeci">#define ECS_IMPORT(world, id)</div><div class="ttdoc">Wrapper around ecs_import.</div><div class="ttdef"><b>Definition:</b> <a href="module_8h_source.html#l00116">module.h:116</a></div></div>
<div class="ttc" id="agroup__c__addons__system_html_gafe627ef7c46f7fac4148a632c3192c81"><div class="ttname"><a href="group__c__addons__system.html#gafe627ef7c46f7fac4148a632c3192c81">ECS_SYSTEM</a></div><div class="ttdeci">#define ECS_SYSTEM(world, id, phase,...)</div><div class="ttdoc">Declare &amp; define a system.</div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l00131">system.h:131</a></div></div>
<div class="ttc" id="agroup__core__types_html_ga7f68bc56147690fc4095ffb29b3679cc"><div class="ttname"><a href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a></div><div class="ttdeci">ecs_id_t ecs_entity_t</div><div class="ttdoc">An entity identifier.</div><div class="ttdef"><b>Definition:</b> <a href="flecs_8h_source.html#l00282">flecs.h:282</a></div></div>
<div class="ttc" id="agroup__core__types_html_ga9ba4521a67d59d716e2d8ba04d4ccb15"><div class="ttname"><a href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a></div><div class="ttdeci">struct ecs_world_t ecs_world_t</div><div class="ttdoc">A world is the container for all ECS data and supporting features.</div><div class="ttdef"><b>Definition:</b> <a href="flecs_8h_source.html#l00291">flecs.h:291</a></div></div>
<div class="ttc" id="agroup__flecs__c__creation_html_ga5a87d6e4371e1551110333d02890a4b8"><div class="ttname"><a href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a></div><div class="ttdeci">#define ECS_COMPONENT(world, id)</div><div class="ttdoc">Declare &amp; define a component.</div><div class="ttdef"><b>Definition:</b> <a href="flecs__c_8h_source.html#l00120">flecs_c.h:120</a></div></div>
<div class="ttc" id="agroup__world__creation__deletion_html_gaa9134e57e2c71d2cd48f701e6673b364"><div class="ttname"><a href="group__world__creation__deletion.html#gaa9134e57e2c71d2cd48f701e6673b364">ecs_fini</a></div><div class="ttdeci">int ecs_fini(ecs_world_t *world)</div><div class="ttdoc">Delete a world.</div></div>
<div class="ttc" id="agroup__world__creation__deletion_html_gad793e918e5aa90eabd1dd218541ffbaf"><div class="ttname"><a href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a></div><div class="ttdeci">ecs_world_t * ecs_init(void)</div><div class="ttdoc">Create a new world.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md131"></a>
Idempotence</h2>
<p >Many operations in the Flecs API are idempotent, meaning that invoking an operation once has the same effect as invoking an operation multiple times with the same parameters. For example:</p>
<div class="fragment"><div class="line">ecs_add(world, e, Position);</div>
</div><!-- fragment --><p >Has the same effect as:</p>
<div class="fragment"><div class="line">ecs_add(world, e, Position);</div>
<div class="line">ecs_add(world, e, Position);</div>
</div><!-- fragment --><p >This simplifies application code as it can be written in a declarative style, where the only thing that matters is that after the operation has been invoked, the post condition of the operation is satisfied.</p>
<p >Some operations are idempotent but have side effects, like <code>ecs_set</code>:</p>
<div class="fragment"><div class="line">ecs_set(world, e, Position, {10, 20});</div>
<div class="line">ecs_set(world, e, Position, {10, 20});</div>
</div><!-- fragment --><p >The effect of invoking this operation once is the same as invoking the operation multiple times, but both invocations can invoke an OnSet observer which can introduce side effects.</p>
<p >All declarative macros (<code>ECS_COMPONENT</code>, <code>ECS_SYSTEM</code>, ...) are idempotent:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Position);</div>
<div class="line">}</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Position);</div>
<div class="line">}</div>
</div><!-- fragment --><p >The second time the <code>ECS_COMPONENT</code> macro is evaluated, the first instance will be found and returned. Note that because these macros may declare variables, they cannot be defined twice in the same C scope.</p>
<h2><a class="anchor" id="autotoc_md132"></a>
Error handling</h2>
<p >As a result of the idempotent design of many operations, the API has a very small error surface. There are essentially two conditions under which an operation is unable to fulfill its postcondition:</p>
<ul>
<li>The application provides invalid inputs to an operation</li>
<li>The operating system is unable to fulfill a request, like a failure to allocate memory</li>
</ul>
<p >When either of those conditions occur, the library will throw an assertion in debug mode (the source is not compiled with <code>NDEBUG</code>). Except for errors caused by the OS, errors are almost always caused by the invocation of a single operation, which makes applications easy to debug.</p>
<p >This approach has several advantages. Application code does not need to check for errors. If an error occurs, the assertion will cause application execution to halt. As a result of this, application code is cleaner and more robust, as it is impossible to forget to handle an error condition.</p>
<h2><a class="anchor" id="autotoc_md133"></a>
Memory ownership</h2>
<p >Most of the API is handle based, as many API constructs are implemented using entities. There are a few instances where an application will interface with memory managed by the framework, or when an application needs to provide memory it manages to the API. In these scenarios there are four rules:</p>
<ul>
<li>If an operation accepts a <code>const T*</code>, the application retains ownership of the memory</li>
<li>If an operation accepts a <code>T*</code>, ownership is transferred from application to framework</li>
<li>If an operation returns a <code>const T*</code>, the framework retains ownership of the memory</li>
<li>If an operation returns a <code>T*</code>, ownership is transferred from framework to application</li>
</ul>
<p >The <code>ecs_get_name</code> operation is an example where the framework retains ownership:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code hl_function" href="group__paths.html#gad844d853ccadef9c5fc11531fa0d9cf8">ecs_get_name</a>(world, e);</div>
<div class="ttc" id="agroup__paths_html_gad844d853ccadef9c5fc11531fa0d9cf8"><div class="ttname"><a href="group__paths.html#gad844d853ccadef9c5fc11531fa0d9cf8">ecs_get_name</a></div><div class="ttdeci">const char * ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)</div><div class="ttdoc">Get the name of an entity.</div></div>
</div><!-- fragment --><p >The <code>ecs_get_fullpath</code> operation is an example where the ownership is transferred to the application:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *path = ecs_get_fullpath(world, e);</div>
</div><!-- fragment --><p >Memory for which ownership has been transferred to the application will need to be freed by the application. This should be done by the <code>ecs_os_free</code> operation:</p>
<div class="fragment"><div class="line">ecs_os_free(path);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md134"></a>
Entity names</h2>
<p >An application can assign names to entities. Names can be assigned at entity creation, with the <code>ecs_entity_init</code> function:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = <a class="code hl_define" href="group__flecs__c__creation.html#ga14bc43363bb1bddd03f25449435a6956">ecs_entity</a>(world, { .name = <span class="stringliteral">&quot;MyEntity&quot;</span> });</div>
<div class="ttc" id="agroup__flecs__c__creation_html_ga14bc43363bb1bddd03f25449435a6956"><div class="ttname"><a href="group__flecs__c__creation.html#ga14bc43363bb1bddd03f25449435a6956">ecs_entity</a></div><div class="ttdeci">#define ecs_entity(world,...)</div><div class="ttdoc">Shorthand for creating an entity with ecs_entity_init.</div><div class="ttdef"><b>Definition:</b> <a href="flecs__c_8h_source.html#l00166">flecs_c.h:166</a></div></div>
</div><!-- fragment --><p >Alternatively, names can be assigned afterwards with the <code>ecs_set_name</code> function:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a>(world, e, <span class="stringliteral">&quot;MyEntity&quot;</span>);</div>
<div class="ttc" id="agroup__paths_html_ga8a031e32a628d7ff62c86d703cae33fb"><div class="ttname"><a href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a></div><div class="ttdeci">ecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)</div><div class="ttdoc">Set the name of an entity.</div></div>
</div><!-- fragment --><p >The <code>ecs_set_name</code> function may be used as a shortcut to create a new named entity by providing 0 for the entity argument:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = <a class="code hl_function" href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a>(world, 0, <span class="stringliteral">&quot;MyEntity&quot;</span>);</div>
</div><!-- fragment --><p >The name of an entity can be retrieved with the <code>ecs_get_name</code> function:</p>
<div class="fragment"><div class="line">printf(<span class="stringliteral">&quot;Name = %s\n&quot;</span>, <a class="code hl_function" href="group__paths.html#gad844d853ccadef9c5fc11531fa0d9cf8">ecs_get_name</a>(world, e));</div>
</div><!-- fragment --><p >The entity name is stored in <code>(<a class="el" href="structEcsIdentifier.html" title="A (string) identifier.">EcsIdentifier</a>, EcsName)</code>. Alternatively, the name can be retrieved with <code>ecs_get_pair</code>: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structEcsIdentifier.html">EcsIdentifier</a> *ptr = ecs_get_pair(world, e, <a class="code hl_struct" href="structEcsIdentifier.html">EcsIdentifier</a>, <a class="code hl_variable" href="group__builtin__tags.html#ga1397208a8281d736572815ca7fb1fa18">EcsName</a>);</div>
<div class="line">printf(<span class="stringliteral">&quot;Name = %s\n&quot;</span>, ptr-&gt;<a class="code hl_variable" href="structEcsIdentifier.html#a8c3166d5e52cadcf595c061c15553210">value</a>);</div>
<div class="ttc" id="agroup__builtin__tags_html_ga1397208a8281d736572815ca7fb1fa18"><div class="ttname"><a href="group__builtin__tags.html#ga1397208a8281d736572815ca7fb1fa18">EcsName</a></div><div class="ttdeci">const ecs_entity_t EcsName</div><div class="ttdoc">Tag to indicate name identifier.</div></div>
<div class="ttc" id="astructEcsIdentifier_html"><div class="ttname"><a href="structEcsIdentifier.html">EcsIdentifier</a></div><div class="ttdoc">A (string) identifier.</div><div class="ttdef"><b>Definition:</b> <a href="flecs_8h_source.html#l01086">flecs.h:1086</a></div></div>
<div class="ttc" id="astructEcsIdentifier_html_a8c3166d5e52cadcf595c061c15553210"><div class="ttname"><a href="structEcsIdentifier.html#a8c3166d5e52cadcf595c061c15553210">EcsIdentifier::value</a></div><div class="ttdeci">char * value</div><div class="ttdoc">Identifier string.</div><div class="ttdef"><b>Definition:</b> <a href="flecs_8h_source.html#l01087">flecs.h:1087</a></div></div>
</div><!-- fragment --><p >Names can be used to lookup entities:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = <a class="code hl_function" href="group__paths.html#ga1ed071d5873ef3e1285bfb48e8240b24">ecs_lookup</a>(world, <span class="stringliteral">&quot;MyEntity&quot;</span>);</div>
<div class="ttc" id="agroup__paths_html_ga1ed071d5873ef3e1285bfb48e8240b24"><div class="ttname"><a href="group__paths.html#ga1ed071d5873ef3e1285bfb48e8240b24">ecs_lookup</a></div><div class="ttdeci">ecs_entity_t ecs_lookup(const ecs_world_t *world, const char *name)</div><div class="ttdoc">Lookup an entity by name.</div></div>
</div><!-- fragment --><p >When an entity is part of a hierarchy, names can be used to form a path:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> parent = <a class="code hl_function" href="group__creating__entities.html#ga2f5f4e7e6590c5cf080e35cdd1ea1c11">ecs_new_id</a>(world);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> child = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a>, parent);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> grandchild = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a>, child);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a>(world, parent, <span class="stringliteral">&quot;Parent&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a>(world, child, <span class="stringliteral">&quot;Child&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a>(world, grandchild, <span class="stringliteral">&quot;GrandChild&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> *path = ecs_get_fullpath(world, grandchild);</div>
<div class="line">printf(<span class="stringliteral">&quot;Path = %s\n&quot;</span>, path); <span class="comment">// prints Parent.Child.GrandChild</span></div>
<div class="line">ecs_os_free(path);</div>
<div class="ttc" id="agroup__builtin__tags_html_ga804836ca51fb3ed3e7346ad084265236"><div class="ttname"><a href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a></div><div class="ttdeci">const ecs_entity_t EcsChildOf</div><div class="ttdoc">Used to express parent-child relationships.</div></div>
<div class="ttc" id="agroup__creating__entities_html_ga2f5f4e7e6590c5cf080e35cdd1ea1c11"><div class="ttname"><a href="group__creating__entities.html#ga2f5f4e7e6590c5cf080e35cdd1ea1c11">ecs_new_id</a></div><div class="ttdeci">ecs_entity_t ecs_new_id(ecs_world_t *world)</div><div class="ttdoc">Create new entity id.</div></div>
</div><!-- fragment --><p >A path can be created relative to a parent:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *path = ecs_get_path(world, parent, grandchild);</div>
<div class="line">printf(<span class="stringliteral">&quot;Path = %s\n&quot;</span>, path); <span class="comment">// prints Child.GrandChild</span></div>
<div class="line">ecs_os_free(path);</div>
</div><!-- fragment --><p >Paths can be used to lookup an entity:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_lookup_fullpath(world, <span class="stringliteral">&quot;Parent.Child.GrandChild&quot;</span>);</div>
</div><!-- fragment --><p >Path lookups may be relative:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_lookup_path(world, parent, <span class="stringliteral">&quot;Child.GrandChild&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md135"></a>
Macros</h2>
<p >The C99 API heavily relies on function-style macros, probably more than you would see in other libraries. The number one reason for this is that an ECS framework needs to work with user-defined types, and C does not provide out of the box support for generics. A few strategies have been employed in the API to improve its overall ergonomics, type safety and readability. Let's start with a simple example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Position {</div>
<div class="line">    <span class="keywordtype">float</span> x;</div>
<div class="line">    <span class="keywordtype">float</span> y;</div>
<div class="line">} Position;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Position);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, Position);</div>
</div><!-- fragment --><p >From a readability perspective this code looks fine as we can easily tell what is happening here. Though if we take a closer look, we can see that a typename is used where we expect an expression, and that is not possible in plain C. So what is going on?</p>
<p >Let's first remove the <code>ECS_COMPONENT</code> macro and replace it with equivalent code (details are omitted for brevity):</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> ecs_id(Position) = <a class="code hl_function" href="group__components.html#ga37d369a391ddf9b21ce0fe319034a3bc">ecs_component_init</a>(world, &amp;(<a class="code hl_struct" href="structecs__component__desc__t.html">ecs_component_desc_t</a>){</div>
<div class="line">    .entity.name = <span class="stringliteral">&quot;Position&quot;</span>,</div>
<div class="line">    .size = <span class="keyword">sizeof</span>(Position),</div>
<div class="line">    .alignment = ECS_ALIGNOF(Position)</div>
<div class="line">});</div>
<div class="ttc" id="agroup__components_html_ga37d369a391ddf9b21ce0fe319034a3bc"><div class="ttname"><a href="group__components.html#ga37d369a391ddf9b21ce0fe319034a3bc">ecs_component_init</a></div><div class="ttdeci">ecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)</div><div class="ttdoc">Find or create a component.</div></div>
<div class="ttc" id="astructecs__component__desc__t_html"><div class="ttname"><a href="structecs__component__desc__t.html">ecs_component_desc_t</a></div><div class="ttdoc">Used with ecs_component_init.</div><div class="ttdef"><b>Definition:</b> <a href="flecs_8h_source.html#l00835">flecs.h:835</a></div></div>
</div><!-- fragment --><p >The first line actually registers the component with Flecs, and captures its name and size. The result is stored in a variable with name <code>ecs_id(Position)</code>. Here, <code>ecs_id</code> is a macro that translates the typename of the component to a variable name. The actual name of the variable is:</p>
<div class="fragment"><div class="line">FLECS__EPosition</div>
</div><!-- fragment --><p >ECS operations that accept a typename, such as <code>ecs_get</code> will look for the <code>FLECS__E</code> variable: </p><div class="fragment"><div class="line">Position *p = ecs_get(world, e, Position);</div>
</div><!-- fragment --><p >Translates into:</p>
<div class="fragment"><div class="line">Position *p = (Position*)<a class="code hl_function" href="group__getting.html#gaa503c048b917cbb22e3edc9f5a10d64b">ecs_get_id</a>(world, e, ecs_id(Position));</div>
<div class="ttc" id="agroup__getting_html_gaa503c048b917cbb22e3edc9f5a10d64b"><div class="ttname"><a href="group__getting.html#gaa503c048b917cbb22e3edc9f5a10d64b">ecs_get_id</a></div><div class="ttdeci">const void * ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)</div><div class="ttdoc">Get an immutable pointer to a component.</div></div>
</div><!-- fragment --><p >As you can see, the <code>ecs_get</code> macro casts the result of the function to the correct type, so a compiler will throw a warning when an application tries to assign the result of the operation to a variable of the wrong type.</p>
<p >Similarly, <code>ecs_set</code> is a macro that ensures that anything we pass into it is of the right type:</p>
<div class="fragment"><div class="line">ecs_set(world, e, Position, {10, 20});</div>
</div><!-- fragment --><p >Translates into:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__getting.html#gaa2d34943f77d88dd2113cdfe74632f18">ecs_set_id</a></div>
<div class="line">    (world, e, ecs_id(Position), <span class="keyword">sizeof</span>(Position),</div>
<div class="line">    &amp;(Position){10, 20});</div>
<div class="ttc" id="agroup__getting_html_gaa2d34943f77d88dd2113cdfe74632f18"><div class="ttname"><a href="group__getting.html#gaa2d34943f77d88dd2113cdfe74632f18">ecs_set_id</a></div><div class="ttdeci">ecs_entity_t ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, size_t size, const void *ptr)</div><div class="ttdoc">Set the value of a component.</div></div>
</div><!-- fragment --><p >In addition to casting the value to the right type and passing in the component, this macro also captures the size of the type, which saves Flecs from having to do a component data lookup.</p>
<p >Understanding how the macros work will go a long way in being able to write effective code in Flecs, and will lead to less surprises when debugging the code.</p>
<h1><a class="anchor" id="autotoc_md136"></a>
Entities</h1>
<p >Entities are uniquely identifiable objects in a game or simulation. In a real time strategy game, there may be entities for the different units, buildings, UI elements and particle effects, but also for example the camera, world and player. An entity does not contain any state, and is not of a particular type. In a traditional OOP-based game, you may expect a tank in the game is of class "Tank". In ECS, an entity is simply a unique identifier, and any data and behavior associated with that entity is implemented with components and systems.</p>
<p >In Flecs, an entity is represented by a 64 bit integer, which is also how it is exposed on the API:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> uint64_t <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a>;</div>
</div><!-- fragment --><p >Zero indicates an invalid entity. Applications can create new entities with the <code>ecs_new</code> operation:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, 0);</div>
</div><!-- fragment --><p >This operation guarantees to return an unused entity identifier. The first entity returned is not 1, as Flecs creates a number of builtin entities during the initialization of the world. The identifier of the first returned entity is stored in the <code>EcsFirstUserEntityId</code> constant.</p>
<h2><a class="anchor" id="autotoc_md137"></a>
Id recycling</h2>
<p >Entity identifiers are reused when deleted. The <code>ecs_new</code> operation will first attempt to recycle a deleted identifier before producing a new one. If no identifier can be recycled, it will return the last issued identifier + 1.</p>
<p >Entity identifiers can only be recycled if they have been deleted with <code>ecs_delete</code>. When <code>ecs_delete</code> is invoked, the generation count of the entity is increased. The generation is encoded in the entity identifier, which means that any existing entity identifiers with the old generation encoded in it will be considered not alive. Calling a delete multiple times on an entity that is not alive has no effect.</p>
<p >When using multiple threads, the <code>ecs_new</code> operation guarantees that the returned identifiers are unique, by using atomic increments instead of a simple increment operation. New ids generated from a thread will not be recycled ids, since this would require taking a lock on the administration. While this does not represent a memory leak, it could cause ids to rise over time. If this happens and is an issue, an application should pre-create the ids.</p>
<h2><a class="anchor" id="autotoc_md138"></a>
Generations</h2>
<p >When an entity is deleted, the generation count for that entity id is increased. The entity generation count enables an application to test whether an entity is still alive or whether it has been deleted, even after the id has been recycled. Consider:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, 0);</div>
<div class="line"><a class="code hl_function" href="group__creating__entities.html#ga9cd74d7c9e8793f65b0055b078f62804">ecs_delete</a>(world, e); <span class="comment">// Increases generation</span></div>
<div class="line"> </div>
<div class="line">e = ecs_new(world, 0); <span class="comment">// Recycles id, but with new generation</span></div>
<div class="ttc" id="agroup__creating__entities_html_ga9cd74d7c9e8793f65b0055b078f62804"><div class="ttname"><a href="group__creating__entities.html#ga9cd74d7c9e8793f65b0055b078f62804">ecs_delete</a></div><div class="ttdeci">void ecs_delete(ecs_world_t *world, ecs_entity_t entity)</div><div class="ttdoc">Delete an entity.</div></div>
</div><!-- fragment --><p >The generation is encoded in the entity id, which means that even though the base id is the same in the above example, the value returned by the second <code>ecs_new</code> is different than the first.</p>
<p >To test whether an entity is alive, an application can use the <code>ecs_is_alive</code> call:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e1 = ecs_new(world, 0);</div>
<div class="line"><a class="code hl_function" href="group__creating__entities.html#ga9cd74d7c9e8793f65b0055b078f62804">ecs_delete</a>(world, e1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e2 = ecs_new(world, 0);</div>
<div class="line"><a class="code hl_function" href="group__liveliness.html#gae0341e7ebf61838c4ce188cccf7592e7">ecs_is_alive</a>(world, e1); <span class="comment">// false</span></div>
<div class="line"><a class="code hl_function" href="group__liveliness.html#gae0341e7ebf61838c4ce188cccf7592e7">ecs_is_alive</a>(world, e2); <span class="comment">// true</span></div>
<div class="ttc" id="agroup__liveliness_html_gae0341e7ebf61838c4ce188cccf7592e7"><div class="ttname"><a href="group__liveliness.html#gae0341e7ebf61838c4ce188cccf7592e7">ecs_is_alive</a></div><div class="ttdeci">bool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)</div><div class="ttdoc">Test whether an entity is alive.</div></div>
</div><!-- fragment --><p >It is not allowed to invoke operations on an entity that is not alive, and doing so may result in an assert. The only operation that is allowed on an entity that is not alive is <code>ecs_delete</code>. Calling delete multiple times on an entity that is not alive will not increase the generation. Additionally, it is also not allowed to add child entities to an entity that is not alive. This will also result in an assert.</p>
<p >There are 16 bits reserved for generation in the entity id, which means that an application can delete the same id 65536 times before the generation resets to 0. To get the current generation of an entity, applications can use the <code>ECS_GENERATION</code> macro. To extract the entity id without the generation, an application can apply the <code>ECS_ENTITY_MASK</code> with a bitwise and:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> generation = ECS_GENERATION(e);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> <span class="keywordtype">id</span> = e &amp; ECS_ENTITY_MASK;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md139"></a>
Manual id generation</h2>
<p >Applications do not have to rely on <code>ecs_new</code> and <code>ecs_delete</code> to create and delete entity identifiers. Entity ids may be used directly, like in this example:</p>
<div class="fragment"><div class="line">ecs_add(world, 42, Position);</div>
</div><!-- fragment --><p >This is particularly useful when the lifecycle of an entity is managed by another data source (like a multiplayer server) and prevents networking code from having to check whether the entity exists. This also allows applications to reuse existing identifiers, as long as these fit inside a 64 bit integer.</p>
<p >When not using manual ids, id recycling mechanisms are bypassed as these are only invoked by the <code>ecs_new</code> and <code>ecs_delete</code> operations. Combining manual ids with <code>ecs_new</code> and <code>ecs_delete</code> can result in unexpected behavior, as <code>ecs_new</code> may return an identifier that an application has already used.</p>
<h2><a class="anchor" id="autotoc_md140"></a>
Id ranges</h2>
<p >An application can instruct Flecs to issue ids from a specific offset and up to a certain limit with the <code>ecs_set_entity_range</code> operation. This example ensures that id generation starts from id 5000:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__world__misc.html#ga8645b6afc6cd506527877426b03c9f62">ecs_set_entity_range</a>(world, 5000, 0);</div>
<div class="ttc" id="agroup__world__misc_html_ga8645b6afc6cd506527877426b03c9f62"><div class="ttname"><a href="group__world__misc.html#ga8645b6afc6cd506527877426b03c9f62">ecs_set_entity_range</a></div><div class="ttdeci">void ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)</div><div class="ttdoc">Set a range for issueing new entity ids.</div></div>
</div><!-- fragment --><p >If the last issued id was higher than 5000, the operation will not cause the last id to be reset to 5000. An application can also specify the highest id that can be generated:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__world__misc.html#ga8645b6afc6cd506527877426b03c9f62">ecs_set_entity_range</a>(world, 5000, 10000);</div>
</div><!-- fragment --><p >If invoking <code>ecs_new</code> would result in an id higher than <code>10000</code>, the application would assert. If <code>0</code> is provided for the maximum id, no upper bound will be enforced.</p>
<p >It is possible for an application to enforce that entity operations (<code>ecs_add</code>, <code>ecs_remove</code>, <code>ecs_delete</code>) are only allowed for the configured range with the <code>ecs_enable_range_check</code> operation:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__world__misc.html#gae88f2f0e95af0f140fbfc440d03e6641">ecs_enable_range_check</a>(world, <span class="keyword">true</span>);</div>
<div class="ttc" id="agroup__world__misc_html_gae88f2f0e95af0f140fbfc440d03e6641"><div class="ttname"><a href="group__world__misc.html#gae88f2f0e95af0f140fbfc440d03e6641">ecs_enable_range_check</a></div><div class="ttdeci">bool ecs_enable_range_check(ecs_world_t *world, bool enable)</div><div class="ttdoc">Enable/disable range limits.</div></div>
</div><!-- fragment --><p >This can be useful for enforcing that an application is not modifying entities that are owned by another data source.</p>
<h1><a class="anchor" id="autotoc_md141"></a>
Types</h1>
<h2><a class="anchor" id="autotoc_md142"></a>
Basic usage</h2>
<p >A type is typically used to describe the contents (components) of an entity. A simple example:</p>
<div class="fragment"><div class="line"><span class="comment">// Create entity with type Position</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, Position);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add Velocity to the entity</span></div>
<div class="line">ecs_add(world, e, Velocity);</div>
</div><!-- fragment --><p >After running this code, the type can be printed:</p>
<div class="fragment"><div class="line"><span class="comment">// Print the type of the entity</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structecs__type__t.html">ecs_type_t</a> *type = <a class="code hl_function" href="group__entity__info.html#ga55091a40ca1423b9d4445d8d6a9eb3d4">ecs_get_type</a>(world, e);</div>
<div class="line"><span class="keywordtype">char</span> *str = <a class="code hl_function" href="group__entity__info.html#ga7e68c96edba74ff583c9d7b9aef5cd30">ecs_type_str</a>(world, type);</div>
<div class="ttc" id="agroup__entity__info_html_ga55091a40ca1423b9d4445d8d6a9eb3d4"><div class="ttname"><a href="group__entity__info.html#ga55091a40ca1423b9d4445d8d6a9eb3d4">ecs_get_type</a></div><div class="ttdeci">const ecs_type_t * ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)</div><div class="ttdoc">Get the type of an entity.</div></div>
<div class="ttc" id="agroup__entity__info_html_ga7e68c96edba74ff583c9d7b9aef5cd30"><div class="ttname"><a href="group__entity__info.html#ga7e68c96edba74ff583c9d7b9aef5cd30">ecs_type_str</a></div><div class="ttdeci">char * ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)</div><div class="ttdoc">Convert type to string.</div></div>
<div class="ttc" id="astructecs__type__t_html"><div class="ttname"><a href="structecs__type__t.html">ecs_type_t</a></div><div class="ttdoc">An array with (component) ids.</div><div class="ttdef"><b>Definition:</b> <a href="flecs_8h_source.html#l00285">flecs.h:285</a></div></div>
</div><!-- fragment --><p >Which will produce:</p>
<div class="fragment"><div class="line">Position, Velocity</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md143"></a>
Advanced usage</h2>
<p >A type is stored as a vector of identifiers. Because components are stored as entities in Flecs, a type is defined as (pseudo, not actual definition):</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> vector&lt;ecs_entity_t&gt; <a class="code hl_struct" href="structecs__type__t.html">ecs_type_t</a>;</div>
</div><!-- fragment --><p >As a result, an application is able to do this:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> tag_1 = ecs_new(world, 0);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> tag_2 = ecs_new(world, 0);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, 0);</div>
<div class="line"><a class="code hl_function" href="group__adding__removing.html#ga2c5629a5ce9eac0414f5389b1e0266c0">ecs_add_id</a>(world, e, tag_1);</div>
<div class="line"><a class="code hl_function" href="group__adding__removing.html#ga2c5629a5ce9eac0414f5389b1e0266c0">ecs_add_id</a>(world, e, tag_2);</div>
<div class="ttc" id="agroup__adding__removing_html_ga2c5629a5ce9eac0414f5389b1e0266c0"><div class="ttname"><a href="group__adding__removing.html#ga2c5629a5ce9eac0414f5389b1e0266c0">ecs_add_id</a></div><div class="ttdeci">void ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)</div><div class="ttdoc">Add a (component) id to an entity.</div></div>
</div><!-- fragment --><p >Printing the contents of the type of <code>e</code> now would produce something similar to:</p>
<div class="fragment"><div class="line">256, 257</div>
</div><!-- fragment --><p >When the type contained components the names of the components were printed. This is because the component entities have a name. The following example sets the names for <code>tag_1</code> and <code>tag_2</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a>(world, tag_1, <span class="stringliteral">&quot;tag_1&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a>(world, tag_2, <span class="stringliteral">&quot;tag_2&quot;</span>);</div>
</div><!-- fragment --><p >Printing the type again will now produce:</p>
<div class="fragment"><div class="line">tag_1, tag_2</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md144"></a>
Components</h1>
<p >A component is a plain datatype that can be attached to an entity. An entity can contain any number of components, and each component can be added only once per entity. Components are registered with a world using the <code>ECS_COMPONENT</code> macro, after which they can be added and removed to and from entities. Components can be of any datatype. The following example shows how to register and use components:</p>
<div class="fragment"><div class="line"><span class="comment">// Components can be defined from regular types</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Position {</div>
<div class="line">    <span class="keywordtype">float</span> x, y;</div>
<div class="line">} Position;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Register the component with the world</span></div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Position);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a new entity with the component</span></div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, Position);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Remove the component from the entity</span></div>
<div class="line">    ecs_remove(world, e, Position);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add the component again</span></div>
<div class="line">    ecs_add(world, e, Position);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Component values can be set with the <code>ecs_set</code> operation. If the entity did not yet have the component, it will be added:</p>
<div class="fragment"><div class="line">ecs_set(world, e, Position, {10, 20});</div>
</div><!-- fragment --><p >Applications can get the value of a component with the <code>ecs_get</code> function:</p>
<p >The value of a component can be requested with <code>ecs_get</code>, which will return <code>NULL</code> if the entity does not have the component:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Position *p = ecs_get(world, e, Position);</div>
</div><!-- fragment --><p >The <code>ecs_get</code> operation returns a const pointer which should not be modified by the application. An application can obtain a mutable pointer with <code>ecs_get_mut</code>. The <code>ecs_get_mut</code> operation ensures that, even when using multiple threads, an application obtains a pointer to a component that can be safely modified, whereas the <code>ecs_get</code> operation might return a pointer to memory that is shared between threads. When an application modified a component obtained with <code>ecs_get_mut</code>, it should invoke <code>ecs_modified</code> to let the framework know the component value was changed. An example:</p>
<div class="fragment"><div class="line">Position *p = ecs_get_mut(world, e, Position);</div>
<div class="line">p-&gt;x++;</div>
<div class="line">ecs_modified(world, e, Position);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md145"></a>
Component handles</h2>
<p >In order to be able to add, remove and set components on an entity, the API needs access to the component handle. A component handle uniquely identifies a component and is passed to API functions. There are two types of handles that are accepted by API functions, a type handle and an entity handle. These handles are automatically defined as variables by the <code>ECS_COMPONENT</code> macro. If an application wants to use the component in another scope, the handle will have to be either declared globally or passed to that scope explicitly.</p>
<h3><a class="anchor" id="autotoc_md146"></a>
Global component handles</h3>
<p >To globally declare a component, an application can use the <code>ECS_COMPONENT_DECLARE</code> and <code>ECS_COMPONENT_DEFINE</code> macros:</p>
<div class="fragment"><div class="line"><span class="comment">// Declare component variable in the global scope</span></div>
<div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#gac15ca7a5ac57590b878f0fc6635284f8">ECS_COMPONENT_DECLARE</a>(Position);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Function that uses the global component variable</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> create_entity(<a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world) {</div>
<div class="line">    <span class="keywordflow">return</span> ecs_new(world, Position);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Register component, assign id to the global component variable</span></div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga26d6cffa50175d9be555633e96916d47">ECS_COMPONENT_DEFINE</a>(world, Position);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = create_entity(world);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="group__world__creation__deletion.html#gaa9134e57e2c71d2cd48f701e6673b364">ecs_fini</a>(world);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__flecs__c__creation_html_ga26d6cffa50175d9be555633e96916d47"><div class="ttname"><a href="group__flecs__c__creation.html#ga26d6cffa50175d9be555633e96916d47">ECS_COMPONENT_DEFINE</a></div><div class="ttdeci">#define ECS_COMPONENT_DEFINE(world, id_)</div><div class="ttdoc">Define a forward declared component.</div><div class="ttdef"><b>Definition:</b> <a href="flecs__c_8h_source.html#l00100">flecs_c.h:100</a></div></div>
<div class="ttc" id="agroup__flecs__c__creation_html_gac15ca7a5ac57590b878f0fc6635284f8"><div class="ttname"><a href="group__flecs__c__creation.html#gac15ca7a5ac57590b878f0fc6635284f8">ECS_COMPONENT_DECLARE</a></div><div class="ttdeci">#define ECS_COMPONENT_DECLARE(id)</div><div class="ttdoc">Forward declare a component.</div><div class="ttdef"><b>Definition:</b> <a href="flecs__c_8h_source.html#l00093">flecs_c.h:93</a></div></div>
</div><!-- fragment --><p >To make a component available for other source files, an application can use the regular <code>extern</code> keyword:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code hl_define" href="group__flecs__c__creation.html#gac15ca7a5ac57590b878f0fc6635284f8">ECS_COMPONENT_DECLARE</a>(Position);</div>
</div><!-- fragment --><p >Declaring components globally works with multiple worlds, as the second time a component is registered it will use the same id. There is one caveat: an application should not define a component in world 2 that is not defined in world 1 <em>before</em> defining the shared components. The reason for this is that if world 2 does not know that the shared component exists, it may assign its id to another component, which can cause a conflict.</p>
<p >If this is something you cannot guarantee in an application, a better (though more verbose) way is to use local component handles.</p>
<h3><a class="anchor" id="autotoc_md147"></a>
Local component handles</h3>
<p >When an application cannot declare component handles globally, it can pass component handles manually. Manually passing component handles takes the variables that are declared by the <code>ECS_COMPONENT</code> macro and passes them to other functions. This section describes how to pass those handles around.</p>
<p >Some operations can process multiple components in a single operation, like <code>ecs_add</code> and <code>ecs_remove</code>. Such operations require a handle of <code><a class="el" href="structecs__type__t.html" title="An array with (component) ids.">ecs_type_t</a></code>. The <code>ECS_COMPONENT</code> macro defines a variable of <code><a class="el" href="structecs__type__t.html" title="An array with (component) ids.">ecs_type_t</a></code> that contains only the id of the component. The variable defined by <code>ECS_COMPONENT</code> can be accessed with <code>ecs_type(ComponentName)</code>. This escapes the component name, which is necessary as it would otherwise conflict with the C type name. The following example shows how to pass a type handle to another function:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Position {</div>
<div class="line">    <span class="keywordtype">float</span> x, y;</div>
<div class="line">} Position;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> new_w_position(<a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *t, <a class="code hl_typedef" href="group__core__types.html#gab6610bdee3f9e204a6a340e603830bb6">ecs_id_t</a> ecs_id(Position)) {</div>
<div class="line">    <span class="comment">// ecs_new uses an ecs_id_t</span></div>
<div class="line">    ecs_new(world, Position);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Position);</div>
<div class="line"> </div>
<div class="line">    new_w_position(world, ecs_id(Position));</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__world__creation__deletion.html#gaa9134e57e2c71d2cd48f701e6673b364">ecs_fini</a>(world);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__types_html_gab6610bdee3f9e204a6a340e603830bb6"><div class="ttname"><a href="group__core__types.html#gab6610bdee3f9e204a6a340e603830bb6">ecs_id_t</a></div><div class="ttdeci">uint64_t ecs_id_t</div><div class="ttdoc">An id.</div><div class="ttdef"><b>Definition:</b> <a href="flecs_8h_source.html#l00279">flecs.h:279</a></div></div>
</div><!-- fragment --><p >The <code>ecs_new</code>, <code>ecs_add</code> and <code>ecs_remove</code> (not exhaustive) functions are wrapper macros around functions functions that accept a component id. The following code is equivalent to the previous example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Position {</div>
<div class="line">    <span class="keywordtype">float</span> x, y;</div>
<div class="line">} Position;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> new_w_position(<a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *t, <a class="code hl_typedef" href="group__core__types.html#gab6610bdee3f9e204a6a340e603830bb6">ecs_id_t</a> p_id) {</div>
<div class="line">    <span class="comment">// Use plain variable name with the ecs_new_w_id operation</span></div>
<div class="line">    <a class="code hl_function" href="group__creating__entities.html#ga121c5b900576d74f970e31c78e2d4119">ecs_new_w_id</a>(world, p_id); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Position);</div>
<div class="line"> </div>
<div class="line">    new_w_position(world, ecs_id(Position));</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__world__creation__deletion.html#gaa9134e57e2c71d2cd48f701e6673b364">ecs_fini</a>(world);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__creating__entities_html_ga121c5b900576d74f970e31c78e2d4119"><div class="ttname"><a href="group__creating__entities.html#ga121c5b900576d74f970e31c78e2d4119">ecs_new_w_id</a></div><div class="ttdeci">ecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t id)</div><div class="ttdoc">Create new entity with (component) id.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md148"></a>
Component disabling</h2>
<p >Components can be disabled, which prevents them from being matched with queries. Contrary to removing a component, disabling a component does not remove it from an entity. When a component is enabled after disabling it, the original value of the component is restored.</p>
<p >To enable or disable a component, use the <code>ecs_enable_component</code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Position {</div>
<div class="line">    <span class="keywordtype">float</span> x, y;</div>
<div class="line">} Position;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Position);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, Position);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Component is enabled by default */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Disable the component */</span></div>
<div class="line">    ecs_enable_component(world, e, Position, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Will return false */</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;%d\n&quot;</span>, ecs_is_enabled_component(world, e, Position));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Re-enable the component */</span></div>
<div class="line">    ecs_enable_component(world, e, Position, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__world__creation__deletion.html#gaa9134e57e2c71d2cd48f701e6673b364">ecs_fini</a>(world);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Component disabling works by maintaining a bitset alongside the component array. When a component is enabled or disabled, the bit that corresponds with the entity is set to 1 or 0. Bitsets are not created by default. Only after invoking the <code>ecs_enable_component</code> operation for an entity will be entity be moved to a table that keeps track of a bitset for that component.</p>
<p >When a query is matched with a table that has a bitset for a component, it will automatically use the bitset to skip disabled values. If an entity contains multiple components tracked by a bitset, the query will evaluate each bitset and only yield entities for which all components are enabled. To ensure optimal performance, the query will always return the largest range of enabled components. Nonetheless, iterating a table with a bitset is slower than a regular table.</p>
<p >If a query is matched with a table that has one or more bitsets, but the query does not match with components tracked by a bitset, there is no performance penalty.</p>
<p >Component disabling can be used to temporarily suspend and resume a component value. It can also be used as a faster alternative to <code>ecs_add</code>/<code>ecs_remove</code>. Since the operation only needs to set a bit, it is a significantly faster alternative to adding/removing components, at the cost of a slightly slower iteration speed. If a component needs to be added or removed frequently, enabling/disabling is recommended.</p>
<h3><a class="anchor" id="autotoc_md149"></a>
Limitations</h3>
<p >Component disabling does not work for components not matched with the entity. If a query matches with a component from a base (prefab) or parent entity and the component is disabled for that entity, the query will not take this into account. If entities with disabled components from a base or parent entity need to be skipped. a query should manually check this.</p>
<p >Because component disabling is implemented with a type role, it cannot be used together with other type roles. This means that it is not possible to disable, for example, tags with <code>SWITCH</code> or <code>CASE</code> roles. Additionally since relationships rely on a role, it is currently not possible to disable relationships such as <code>(ChildOf, parent)</code> or <code>(IsA, prefab)</code>.</p>
<p >Another limitation is that currently the query NOT (!) operator does not take into account disabled entities. The optional operator (?) technically works, but a query is unable to see whether a component has been set or not as both the enabled and disabled values are returned to the application in a single array.</p>
<h1><a class="anchor" id="autotoc_md150"></a>
Tagging</h1>
<p >Tags are much like components, but they are not associated with a data type. Tags are typically used to add a flag to an entity, for example to indicate that an entity is an Enemy:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Register the tag with the world. There is no Enemy type</span></div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga6d1d4e4fb0236c6c22945b4dcc74b043">ECS_TAG</a>(world, Enemy);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add the Enemy tag</span></div>
<div class="line">    ecs_add(world, e, Enemy);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Remove the Enemy tag</span></div>
<div class="line">    ecs_remove(world, e, Enemy);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__flecs__c__creation_html_ga6d1d4e4fb0236c6c22945b4dcc74b043"><div class="ttname"><a href="group__flecs__c__creation.html#ga6d1d4e4fb0236c6c22945b4dcc74b043">ECS_TAG</a></div><div class="ttdeci">#define ECS_TAG(world, id)</div><div class="ttdoc">Declare &amp; define a tag.</div><div class="ttdef"><b>Definition:</b> <a href="flecs__c_8h_source.html#l00073">flecs_c.h:73</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md151"></a>
Tag handles</h2>
<p >Just like components, the API needs a handle to a tag before it can use it, and just like <code>ECS_COMPONENT</code>, the <code>ECS_TAG</code> macro defines two variables, one of type <code><a class="el" href="structecs__type__t.html" title="An array with (component) ids.">ecs_type_t</a></code> and one of <code>ecs_entity_t</code>. Passing a handle of an <code><a class="el" href="structecs__type__t.html" title="An array with (component) ids.">ecs_type_t</a></code> into a function looks similar to a component:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> new_w_tag(<a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *t, <a class="code hl_struct" href="structecs__type__t.html">ecs_type_t</a> ecs_type(Tag)) {</div>
<div class="line">    <span class="comment">// ecs_new uses an ecs_type_t</span></div>
<div class="line">    ecs_new(world, Tag);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga6d1d4e4fb0236c6c22945b4dcc74b043">ECS_TAG</a>(world, Tag);</div>
<div class="line"> </div>
<div class="line">    new_w_tag(world, ecs_type(Tag));</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__world__creation__deletion.html#gaa9134e57e2c71d2cd48f701e6673b364">ecs_fini</a>(world);</div>
<div class="line">}</div>
</div><!-- fragment --><p >For functions that require an <code>ecs_entity_t</code> handle, the tag variable names are not escaped, since they do not clash with a C type name. An example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> add_tag(<a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *t, <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e, <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> Tag) {</div>
<div class="line">    <a class="code hl_function" href="group__adding__removing.html#ga2c5629a5ce9eac0414f5389b1e0266c0">ecs_add_id</a>(world, e, Tag);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga6d1d4e4fb0236c6c22945b4dcc74b043">ECS_TAG</a>(world, Tag);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, 0);</div>
<div class="line">    add_tag(world, e, Tag);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__world__creation__deletion.html#gaa9134e57e2c71d2cd48f701e6673b364">ecs_fini</a>(world);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Anyone who paid careful attention to this example will notice that the <code>ecs_add_id</code> operation accepts two regular entities.</p>
<h1><a class="anchor" id="autotoc_md152"></a>
Observers</h1>
<p >Observers are callbacks that are invoked when one or more events matches the query of an observer. Events can be either user defined or builtin. Examples of builtin events are <code>OnAdd</code>, <code>OnRemove</code> and <code>OnSet</code>.</p>
<p >When an observer has a query with more than one component, the observer will not match until the entity for which the event is emitted satisfies the entire query.</p>
<p >An example of an observer with a single component:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga1d62f6136863c879e4f024138a62fa82">ECS_OBSERVER</a>(world, AddPosition, <a class="code hl_variable" href="group__builtin__tags.html#gabf838ed66ad4d8b54a37ef414f5a667a">EcsOnAdd</a>, Position);</div>
<div class="ttc" id="agroup__builtin__tags_html_gabf838ed66ad4d8b54a37ef414f5a667a"><div class="ttname"><a href="group__builtin__tags.html#gabf838ed66ad4d8b54a37ef414f5a667a">EcsOnAdd</a></div><div class="ttdeci">const ecs_entity_t EcsOnAdd</div><div class="ttdoc">Event.</div></div>
<div class="ttc" id="agroup__flecs__c__creation_html_ga1d62f6136863c879e4f024138a62fa82"><div class="ttname"><a href="group__flecs__c__creation.html#ga1d62f6136863c879e4f024138a62fa82">ECS_OBSERVER</a></div><div class="ttdeci">#define ECS_OBSERVER(world, id, kind,...)</div><div class="ttdoc">Declare &amp; define an observer.</div><div class="ttdef"><b>Definition:</b> <a href="flecs__c_8h_source.html#l00152">flecs_c.h:152</a></div></div>
</div><!-- fragment --><p >The implementation of the observer looks similar to a system:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> AddPosition(ecs_iter_t *it) {</div>
<div class="line">    Position *p = ecs_field(it, Position, 1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; it-&gt;count; i++) {</div>
<div class="line">        p[i].x = 10;</div>
<div class="line">        p[i].y = 20;</div>
<div class="line">        printf(<span class="stringliteral">&quot;Position added\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md153"></a>
Modules</h1>
<p >Modules allow an application to split up systems and components into separate decoupled units. The purpose of modules is to make it easier to organize systems and components for large projects. Additionally, modules also make it easier to split off functionality into separate compilation units.</p>
<p >A module consists out of a couple parts:</p>
<ul>
<li>The declaration of the components, tags, and systems of the module contents</li>
<li>An import function that loads the module contents for a world</li>
</ul>
<p >The declaration of the module contents module is typically located in a separate module header file, and look like this for a module named "Vehicles":</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Car {</div>
<div class="line">    <span class="keywordtype">float</span> speed;</div>
<div class="line">} Car;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Bus {</div>
<div class="line">    <span class="keywordtype">float</span> speed;</div>
<div class="line">} Bus;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MotorCycle {</div>
<div class="line">    <span class="keywordtype">float</span> speed;</div>
<div class="line">} MotorCycle;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Components are declared with ECS_COMPONENT_DECLARE */</span></div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_define" href="group__flecs__c__creation.html#gac15ca7a5ac57590b878f0fc6635284f8">ECS_COMPONENT_DECLARE</a>(Car);</div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_define" href="group__flecs__c__creation.html#gac15ca7a5ac57590b878f0fc6635284f8">ECS_COMPONENT_DECLARE</a>(Bus);</div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_define" href="group__flecs__c__creation.html#gac15ca7a5ac57590b878f0fc6635284f8">ECS_COMPONENT_DECLARE</a>(MotorCycle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Tags are declared with ECS_DECLARE */</span></div>
<div class="line"><span class="keyword">extern</span> ECS_DECLARE(Moving);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Systems are declared with ECS_SYSTEM_DECLARE */</span></div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_define" href="group__c__addons__system.html#gacbe0496c8b7d3a4a15af14fcddc17aaa">ECS_SYSTEM_DECLARE</a>(Move);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Forward declaration to the import function */</span></div>
<div class="line"><span class="comment">/* The function name has to follow the convention: &lt;ModuleName&gt;Import */</span></div>
<div class="line"><span class="keywordtype">void</span> VehiclesImport(<a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world);</div>
<div class="ttc" id="agroup__c__addons__system_html_gacbe0496c8b7d3a4a15af14fcddc17aaa"><div class="ttname"><a href="group__c__addons__system.html#gacbe0496c8b7d3a4a15af14fcddc17aaa">ECS_SYSTEM_DECLARE</a></div><div class="ttdeci">#define ECS_SYSTEM_DECLARE(id)</div><div class="ttdoc">Forward declare a system.</div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l00104">system.h:104</a></div></div>
</div><!-- fragment --><p >The import function for this module is typically located in a module source file, and would look like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> VehiclesImport(<a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world) {</div>
<div class="line">    <span class="comment">/* Define the module */</span></div>
<div class="line">    ECS_MODULE(world, Vehicles);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Declare components, tags, systems, and assign them to the module with their respective _DEFINE macros */</span></div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga26d6cffa50175d9be555633e96916d47">ECS_COMPONENT_DEFINE</a>(world, Car);</div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga26d6cffa50175d9be555633e96916d47">ECS_COMPONENT_DEFINE</a>(world, Bus);</div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga26d6cffa50175d9be555633e96916d47">ECS_COMPONENT_DEFINE</a>(world, MotorCycle);</div>
<div class="line">    <a class="code hl_define" href="group__flecs__c__creation.html#ga863fdad64aedde0d2672f438cead5a37">ECS_TAG_DEFINE</a>(world, Moving);</div>
<div class="line">    <a class="code hl_define" href="group__c__addons__system.html#ga3f9dda6bdd469ab59cacb5f848c10f65">ECS_SYSTEM_DEFINE</a>(world, Move, EcsOnUpdate, Car, Moving);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__c__addons__system_html_ga3f9dda6bdd469ab59cacb5f848c10f65"><div class="ttname"><a href="group__c__addons__system.html#ga3f9dda6bdd469ab59cacb5f848c10f65">ECS_SYSTEM_DEFINE</a></div><div class="ttdeci">#define ECS_SYSTEM_DEFINE(world, id_, phase,...)</div><div class="ttdoc">Define a forward declared system.</div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l00111">system.h:111</a></div></div>
<div class="ttc" id="agroup__flecs__c__creation_html_ga863fdad64aedde0d2672f438cead5a37"><div class="ttname"><a href="group__flecs__c__creation.html#ga863fdad64aedde0d2672f438cead5a37">ECS_TAG_DEFINE</a></div><div class="ttdeci">#define ECS_TAG_DEFINE(world, id)</div><div class="ttdoc">Define a forward declared tag.</div><div class="ttdef"><b>Definition:</b> <a href="flecs__c_8h_source.html#l00066">flecs_c.h:66</a></div></div>
</div><!-- fragment --><p >After the module has been defined, it can be imported in an application like this:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga9ba4521a67d59d716e2d8ba04d4ccb15">ecs_world_t</a> *world = <a class="code hl_function" href="group__world__creation__deletion.html#gad793e918e5aa90eabd1dd218541ffbaf">ecs_init</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Import module, which invokes the module import function */</span></div>
<div class="line"><a class="code hl_define" href="group__c__addons__module.html#gae3c27bd0ac0793f8a9a3cada8b39f86f">ECS_IMPORT</a>(world, Vehicles);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The module contents can now be used */</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, Car);</div>
</div><!-- fragment --><p >Module contents are namespaced, which means that the identifiers of the content of the module (components, tags, systems) are stored in the scope of the module. For the above example module, everything would be stored in the <code>vehicles</code> scope. To resolve the <code>Car</code> component by name, an application would have to do:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> car_entity = ecs_lookup_fullpath(world, <span class="stringliteral">&quot;vehicles.Car&quot;</span>);</div>
</div><!-- fragment --><p >Note that even though the module name is specified with uppercase, the name is stored with lowercase. This is because the naming convention for modules in C is PascalCase, whereas the stored identifiers use snake_case. If a module name contains several uppercase letters, this will be translated to a nested module. For example, the C module name <code>MySimpleModule</code> will be translated to <code>my.simple.module</code>.</p>
<h2><a class="anchor" id="autotoc_md154"></a>
Modules in C++</h2>
<p >A module in C++ is defined as a class where the module contents are defined in the constructor. The above Vehicles module would look like this in C++:</p>
<div class="fragment"><div class="line"><span class="comment">/* In C++ it is more convenient to define tags as empty structs */</span></div>
<div class="line"><span class="keyword">struct </span>Moving { };</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Module implementation */</span></div>
<div class="line"><span class="keyword">class </span>vehicles {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    vehicles(<a class="code hl_struct" href="structflecs_1_1world.html">flecs::world</a>&amp; world) {</div>
<div class="line">        flecs::module&lt;Vehicles&gt;(world, <span class="stringliteral">&quot;vehicles&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        m_car = <a class="code hl_struct" href="structflecs_1_1component.html">flecs::component&lt;Car&gt;</a>(world, <span class="stringliteral">&quot;Car&quot;</span>);</div>
<div class="line">        m_bus = <a class="code hl_struct" href="structflecs_1_1component.html">flecs::component&lt;Bus&gt;</a>(world, <span class="stringliteral">&quot;Bus&quot;</span>);</div>
<div class="line">        m_motor_cycle = <a class="code hl_struct" href="structflecs_1_1component.html">flecs::component&lt;MotorCycle&gt;</a>(world, <span class="stringliteral">&quot;MotorCycle&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        m_moving = <a class="code hl_struct" href="structflecs_1_1component.html">flecs::component&lt;Moving&gt;</a>(world, <span class="stringliteral">&quot;Moving&quot;</span>);</div>
<div class="line">        m_move = <a class="code hl_struct" href="structflecs_1_1system.html">flecs::system&lt;Car, Moving&gt;</a>(world, <span class="stringliteral">&quot;Move&quot;</span>)</div>
<div class="line">            .<a class="code hl_function" href="structflecs_1_1entity__view.html#a9fdf9fb51173722f07ce3c5b5011ba66">each</a>([](<a class="code hl_struct" href="structflecs_1_1entity.html">flecs::entity</a> e, Car &amp;car, Moving&amp;) {</div>
<div class="line">                <span class="comment">/* System implementation */</span></div>
<div class="line">            });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structflecs_1_1entity.html">flecs::entity</a> m_car;</div>
<div class="line">    <a class="code hl_struct" href="structflecs_1_1entity.html">flecs::entity</a> m_bus;</div>
<div class="line">    <a class="code hl_struct" href="structflecs_1_1entity.html">flecs::entity</a> m_motor_cycle;</div>
<div class="line">    <a class="code hl_struct" href="structflecs_1_1entity.html">flecs::entity</a> m_moving;</div>
<div class="line">    <a class="code hl_struct" href="structflecs_1_1entity.html">flecs::entity</a> m_move;</div>
<div class="line">}</div>
<div class="ttc" id="astructflecs_1_1component_html"><div class="ttname"><a href="structflecs_1_1component.html">flecs::component</a></div><div class="ttdoc">Component class.</div><div class="ttdef"><b>Definition:</b> <a href="component_8hpp_source.html#l00348">component.hpp:348</a></div></div>
<div class="ttc" id="astructflecs_1_1entity__view_html_a9fdf9fb51173722f07ce3c5b5011ba66"><div class="ttname"><a href="structflecs_1_1entity__view.html#a9fdf9fb51173722f07ce3c5b5011ba66">flecs::entity_view::each</a></div><div class="ttdeci">void each(const Func &amp;func) const</div><div class="ttdoc">Iterate (component) ids of an entity.</div><div class="ttdef"><b>Definition:</b> <a href="entity_2impl_8hpp_source.html#l00117">impl.hpp:117</a></div></div>
<div class="ttc" id="astructflecs_1_1entity_html"><div class="ttname"><a href="structflecs_1_1entity.html">flecs::entity</a></div><div class="ttdoc">Entity.</div><div class="ttdef"><b>Definition:</b> <a href="entity_8hpp_source.html#l00029">entity.hpp:30</a></div></div>
<div class="ttc" id="astructflecs_1_1system_html"><div class="ttname"><a href="structflecs_1_1system.html">flecs::system</a></div><div class="ttdef"><b>Definition:</b> <a href="system_2impl_8hpp_source.html#l00067">impl.hpp:68</a></div></div>
<div class="ttc" id="astructflecs_1_1world_html"><div class="ttname"><a href="structflecs_1_1world.html">flecs::world</a></div><div class="ttdoc">The world.</div><div class="ttdef"><b>Definition:</b> <a href="world_8hpp_source.html#l00113">world.hpp:113</a></div></div>
</div><!-- fragment --><p >An application can import the module in C++ like this:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structflecs_1_1world.html">flecs::world</a> world;</div>
<div class="line">flecs::import&lt;vehicles&gt;(world);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md155"></a>
Hierarchies</h1>
<p >Entities in Flecs can be organized in hierarchies, which is useful when for example constructing a scene graph. To create hierarchies, applications can add <code>ChildOf</code> relationships to entities. This creates a relationship between a parent entity and a child entity that the application can later traverse. This is an example of a simple hierarchy:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> parent = ecs_new(world, 0);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> child = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a>, parent);</div>
</div><!-- fragment --><p ><code>ChildOf</code> relationships can be added and removed dynamically, similar to how components can be added and removed:</p>
<div class="fragment"><div class="line">ecs_add_pair(world, child, <a class="code hl_variable" href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a>, parent);</div>
<div class="line">ecs_remove_pair(world, child, <a class="code hl_variable" href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a>, parent);</div>
</div><!-- fragment --><p ><code>ChildOf</code> relationships can also be created through the <code>ECS_ENTITY</code> macro:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a>(world, parent, 0);</div>
<div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a>(world, child, (ChildOf, parent));</div>
<div class="ttc" id="agroup__flecs__c__creation_html_ga40af675acbf69a6cdc528d06d7533aef"><div class="ttname"><a href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a></div><div class="ttdeci">#define ECS_ENTITY(world, id,...)</div><div class="ttdoc">Declare &amp; define an entity.</div><div class="ttdef"><b>Definition:</b> <a href="flecs__c_8h_source.html#l00053">flecs_c.h:53</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md156"></a>
Iteration</h2>
<p >Applications can iterate hierarchies depth first with the <code>ecs_children</code> API in C, and the <code>children()</code> iterator in C++. This example shows how to iterate all the children of an entity:</p>
<p >In C: </p><div class="fragment"><div class="line">ecs_iter_t it = <a class="code hl_function" href="group__filters.html#ga9182f54435168ae02d4540dff9b9e2fc">ecs_children</a>(world, parent);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>(<a class="code hl_function" href="group__filters.html#ga0b563eabccb6895c42c8f392b61fefd8">ecs_children_next</a>(&amp;it)) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; it.count; i++) {</div>
<div class="line">        <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> child = it.entities[i];</div>
<div class="line">        <span class="keywordtype">char</span> *path = ecs_get_fullpath(world, child);</div>
<div class="line">        printf(<span class="stringliteral">&quot;%s\n&quot;</span>, path);</div>
<div class="line">        free(path);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__filters_html_ga0b563eabccb6895c42c8f392b61fefd8"><div class="ttname"><a href="group__filters.html#ga0b563eabccb6895c42c8f392b61fefd8">ecs_children_next</a></div><div class="ttdeci">bool ecs_children_next(ecs_iter_t *it)</div><div class="ttdoc">Progress a children iterator.</div></div>
<div class="ttc" id="agroup__filters_html_ga9182f54435168ae02d4540dff9b9e2fc"><div class="ttname"><a href="group__filters.html#ga9182f54435168ae02d4540dff9b9e2fc">ecs_children</a></div><div class="ttdeci">ecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)</div><div class="ttdoc">Iterator for a parent's children.</div></div>
</div><!-- fragment --><p >In C++: </p><div class="fragment"><div class="line">e.children([&amp;](<a class="code hl_struct" href="structflecs_1_1entity.html">flecs::entity</a> child) {</div>
<div class="line">    std::cout &lt;&lt; child.<a class="code hl_function" href="structflecs_1_1entity__view.html#a293786fdb95262227514b487097b81be">path</a>() &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="ttc" id="astructflecs_1_1entity__view_html_a293786fdb95262227514b487097b81be"><div class="ttname"><a href="structflecs_1_1entity__view.html#a293786fdb95262227514b487097b81be">flecs::entity_view::path</a></div><div class="ttdeci">flecs::string path(const char *sep=&quot;::&quot;, const char *init_sep=&quot;::&quot;) const</div><div class="ttdoc">Return the entity path.</div><div class="ttdef"><b>Definition:</b> <a href="entity__view_8hpp_source.html#l00094">entity_view.hpp:94</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md157"></a>
Hierarchical queries</h2>
<p >Queries and systems can request data from parents of the entity being iterated over with the <code>parent</code> modifier:</p>
<div class="fragment"><div class="line"><span class="comment">// Iterate all entities with Position that have a parent that also has Position</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#gac0a8d652ea05cdd4daf1f3900b39b4fb">ecs_query_t</a> *q = ecs_query_new(world, <span class="stringliteral">&quot;Position(parent), Position&quot;</span>);</div>
<div class="ttc" id="agroup__core__types_html_gac0a8d652ea05cdd4daf1f3900b39b4fb"><div class="ttname"><a href="group__core__types.html#gac0a8d652ea05cdd4daf1f3900b39b4fb">ecs_query_t</a></div><div class="ttdeci">struct ecs_query_t ecs_query_t</div><div class="ttdoc">A query allows for cached iteration over ECS data.</div><div class="ttdef"><b>Definition:</b> <a href="flecs_8h_source.html#l00300">flecs.h:300</a></div></div>
</div><!-- fragment --><p >Additionally, a query can iterate the hierarchy in breadth-first order by providing the <code>cascade</code> modifier:</p>
<div class="fragment"><div class="line"><span class="comment">// Iterate all entities with Position that have a parent that also has Position</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#gac0a8d652ea05cdd4daf1f3900b39b4fb">ecs_query_t</a> *q = ecs_query_new(world, <span class="stringliteral">&quot;Position(parent|cascade), Position&quot;</span>);</div>
</div><!-- fragment --><p >This does two things. First, it will iterate over all entities that have Position and that <em>optionally</em> have a parent that has <code>Position</code>. By making the parent component optional, it is ensured that if an application is iterating a tree of entities, the root is also included. Secondly, the query iterates over the children in breadth-first order. This is particularly useful when writing transform systems, as they require parent entities to be transformed before child entities.</p>
<p >The above query does not match root entities, as they do not have a parent with <code>Position</code>. To also match root entities, add <code>?</code> to make the term optional:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#gac0a8d652ea05cdd4daf1f3900b39b4fb">ecs_query_t</a> *q = ecs_query_new(world, <span class="stringliteral">&quot;?Position(parent|cascade), Position&quot;</span>);</div>
</div><!-- fragment --><p >See the <a class="el" href="md_docs_Queries.html">query manual</a> section for more details.</p>
<h2><a class="anchor" id="autotoc_md158"></a>
Path identifiers</h2>
<p >When entities in a hierarchy have names assigned to them, they can be looked up with path expressions. A path expression is a list of entity names, separated by a scope separator character (by default a <code>.</code>, and <code>::</code> in the C++ API). This example shows how to request the path expression from an entity:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a>(world, parent, 0);</div>
<div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a>(world, child, (ChildOf, parent));</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> *path = ecs_get_fullpath(world, child);</div>
<div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, path); <span class="comment">// Prints  &quot;parent.child&quot;</span></div>
<div class="line">free(path);</div>
</div><!-- fragment --><p >To lookup an entity using a path, use <code>ecs_lookup_fullpath</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_lookup_fullpath(world, <span class="stringliteral">&quot;parent.child&quot;</span>);</div>
</div><!-- fragment --><p >Applications can also lookup entities using a relative path expression:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_lookup_path(world, parent, <span class="stringliteral">&quot;child.grand_child&quot;</span>);</div>
</div><!-- fragment --><p >Additionally, applications can specify a custom path separator when looking up or requesting paths:</p>
<div class="fragment"><div class="line"><span class="comment">// Lookup child::grand_child relative to parent</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = <a class="code hl_function" href="group__paths.html#gabc56f61e16c18b6fa9c277f24d15e2ee">ecs_lookup_path_w_sep</a>(</div>
<div class="line">    world, parent, <span class="stringliteral">&quot;child::grand_child&quot;</span>, <span class="stringliteral">&quot;::&quot;</span>, <span class="stringliteral">&quot;::&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get path of child relative to parent</span></div>
<div class="line"><span class="keywordtype">char</span> *path = <a class="code hl_function" href="group__paths.html#ga0f5147c0475ee6783ec332889b10c005">ecs_get_path_w_sep</a>(world, parent, child, <span class="stringliteral">&quot;::&quot;</span>, <span class="stringliteral">&quot;::&quot;</span>);</div>
<div class="ttc" id="agroup__paths_html_ga0f5147c0475ee6783ec332889b10c005"><div class="ttname"><a href="group__paths.html#ga0f5147c0475ee6783ec332889b10c005">ecs_get_path_w_sep</a></div><div class="ttdeci">char * ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)</div><div class="ttdoc">Get a path identifier for an entity.</div></div>
<div class="ttc" id="agroup__paths_html_gabc56f61e16c18b6fa9c277f24d15e2ee"><div class="ttname"><a href="group__paths.html#gabc56f61e16c18b6fa9c277f24d15e2ee">ecs_lookup_path_w_sep</a></div><div class="ttdeci">ecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, bool recursive)</div><div class="ttdoc">Lookup an entity from a path.</div></div>
</div><!-- fragment --><p >Note that the path separator is provided twice, once for the prefix and once for the separator. This lets the API correctly handle expressions like <code>::parent::child::grand_child</code>.</p>
<h2><a class="anchor" id="autotoc_md159"></a>
Scoping</h2>
<p >Applications can set a default scope with the <code>ecs_set_scope</code> function, so that all operations are evaluated relative to a scope. The scope is set on a stage, which makes it thread safe when executed from within a flecs worker thread. This example shows how to set the scope:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> parent = ecs_new(world, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the current scope to the parent</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> prev_scope = <a class="code hl_function" href="group__paths.html#gae648e450d1cb2720f86447597fc4e292">ecs_set_scope</a>(world, parent);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This entity is created as child of parent</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> child = ecs_new(world, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Look for &quot;child&quot; relative to parent</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_lookup_fullpath(world, <span class="stringliteral">&quot;child&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// It&#39;s good practice to restore the previous scope</span></div>
<div class="line"><a class="code hl_function" href="group__paths.html#gae648e450d1cb2720f86447597fc4e292">ecs_set_scope</a>(prev_scope);</div>
<div class="ttc" id="agroup__paths_html_gae648e450d1cb2720f86447597fc4e292"><div class="ttname"><a href="group__paths.html#gae648e450d1cb2720f86447597fc4e292">ecs_set_scope</a></div><div class="ttdeci">ecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)</div><div class="ttdoc">Set the current scope.</div></div>
</div><!-- fragment --><p >Modules automatically set the scope to the module itself, so that the module acts as a namespace for its contents.</p>
<h2><a class="anchor" id="autotoc_md160"></a>
Paths and signatures</h2>
<p >When referencing entities or components in a signature or type expression that are not stored in the root, an application will have to provide the path. Signatures and type expressions always use the dot (<code>.</code>) as separator. For example, if a component "Position" is defined in the module "transform", a system subscribing for the component would have to be defined like this:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__c__addons__system.html#gafe627ef7c46f7fac4148a632c3192c81">ECS_SYSTEM</a>(world, Move, EcsOnUpdate, transform.Position);</div>
</div><!-- fragment --><p >The same goes for other parts of the API that accept a type expression, like <code>ECS_ENTITY</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a>(world, Movable, transform.Position);</div>
</div><!-- fragment --><p >If the system would be defined in the same scope as the <code>Position</code> component, it would not need to specify the path:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a>(world, transform, 0);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> prev_scope = <a class="code hl_function" href="group__paths.html#gae648e450d1cb2720f86447597fc4e292">ecs_set_scope</a>(world, transform);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga5a87d6e4371e1551110333d02890a4b8">ECS_COMPONENT</a>(world, Position);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// System is in the same scope, no need to add &quot;transform&quot;</span></div>
<div class="line"><a class="code hl_define" href="group__c__addons__system.html#gafe627ef7c46f7fac4148a632c3192c81">ECS_SYSTEM</a>(world, MoveInScope, EcsOnUpdate, Position);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__paths.html#gae648e450d1cb2720f86447597fc4e292">ecs_set_scope</a>(world, prev_scope);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This system is not in the same scope, and needs to add transform</span></div>
<div class="line"><a class="code hl_define" href="group__c__addons__system.html#gafe627ef7c46f7fac4148a632c3192c81">ECS_SYSTEM</a>(world, MoveNotInScope, EcsOnUpdate, transform.Position);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md161"></a>
Inheritance</h1>
<p >Inheritance is the ability to share components between entities by <em>inheriting</em> from them, by using the <code>IsA</code> relationship. This is a simple example in the C API:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a base entity</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> base = ecs_new(world, 0);</div>
<div class="line">ecs_set(world, base, Position, {10, 20});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Derive from base</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, base);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// e now shares Position with base</span></div>
<div class="line">ecs_get(world, base, Position) == ecs_get(world, e, Position); <span class="comment">// 1</span></div>
<div class="ttc" id="agroup__builtin__tags_html_ga61e41a3ca391d17da70b088989d9048b"><div class="ttname"><a href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a></div><div class="ttdeci">const ecs_entity_t EcsIsA</div><div class="ttdoc">Used to express inheritance relationships.</div></div>
</div><!-- fragment --><p ><code>IsA</code> relationships can be added and removed dynamically, similar to how components can be added and removed:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__adding__removing.html#ga2c5629a5ce9eac0414f5389b1e0266c0">ecs_add_id</a>(world, e, (IsA, base));</div>
<div class="line"><a class="code hl_function" href="group__adding__removing.html#ga553bb47a23309f088a6c7649656c36cb">ecs_remove_id</a>(world, e, (IsA, base));</div>
<div class="ttc" id="agroup__adding__removing_html_ga553bb47a23309f088a6c7649656c36cb"><div class="ttname"><a href="group__adding__removing.html#ga553bb47a23309f088a6c7649656c36cb">ecs_remove_id</a></div><div class="ttdeci">void ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)</div><div class="ttdoc">Remove a (component) id from an entity.</div></div>
</div><!-- fragment --><p ><code>IsA</code> relationships can also be created through the <code>ECS_ENTITY</code> macro:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a>(world, base, Position);</div>
<div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a>(world, e, (IsA, base));</div>
</div><!-- fragment --><p ><code>IsA</code> relationships can be nested:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> base = ecs_new(world, 0);</div>
<div class="line">ecs_set(world, base, Position, {10, 20});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> derived = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, base);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Derive from &quot;derived&quot; which is itself derived from base</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, derived);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// All three entities now share Position</span></div>
<div class="line">ecs_get(world, base, Position) == ecs_get(world, e, Position); <span class="comment">// 1</span></div>
<div class="line">ecs_get(world, base, Position) == ecs_get(world, derived, Position);  <span class="comment">// 1</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md162"></a>
Overriding</h2>
<p >Derived entities can override components from their base by adding the component as they would normally. When overriding a component, the value of the base component is copied to the entity. This example shows how a derived entity overrides the Position component:</p>
<div class="fragment"><div class="line"><span class="comment">// Shortcut for creating a base entity and setting Position</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> base = ecs_set(world, 0, Position, {10, 20});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Derive from the base</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, base);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Override Position</span></div>
<div class="line">ecs_add(world, e, Position);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Position component no longer matches with base</span></div>
<div class="line">ecs_get(world, base, Position) != ecs_get(world, e, Position); <span class="comment">// 1</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prints {10, 20}</span></div>
<div class="line"><span class="keyword">const</span> Position *p = ecs_get(world, e, Position);</div>
<div class="line">printf(<span class="stringliteral">&quot;{%f, %f}\n&quot;</span>, p-&gt;x, p-&gt;y);</div>
</div><!-- fragment --><p >When an entity shared a component from a base entity, we say that the component is "shared". If the component is not shared, it is "owned". After an entity overrides a component, it will own the component.</p>
<p >It is possible to remove an override, in which case the component will be shared with the base entity again:</p>
<div class="fragment"><div class="line"><span class="comment">// Removes override on Position</span></div>
<div class="line">ecs_remove(world, e, Position);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Position is again shared with base</span></div>
<div class="line">ecs_get(world, base, Position) == ecs_get(world, e, Position); <span class="comment">// 1</span></div>
</div><!-- fragment --><p >Overrides work with nested <code>IsA</code> relationships:</p>
<div class="fragment"><div class="line"><span class="comment">// Shortcut for creating a base entity and setting Position</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> base = ecs_new(world, 0);</div>
<div class="line">ecs_set(world, base, Position, {10, 20});</div>
<div class="line">ecs_set(world, base, Velocity, {1, 1});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create derived entity, override Position</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> derived = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, base);</div>
<div class="line">ecs_add(world, base, Position);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Derive from &#39;derived&#39;, which is derived from base</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, derived);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The entity now shares Position from derived, and Velocity from base</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md163"></a>
Automatic overriding</h2>
<p >In some scenarios it is desirable that an entity is initialized with a specific set of values, yet does not share the components from the base entity. In this case the derived entity can override each component individually, but this can become hard to maintain as components are added or removed to the base. This can be achieved by marking components as owned. Consider the following example:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a base. Simply deriving the base will share the component, but not override it.</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> Base = ecs_set(world, 0, Position, {10, 20});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Mark as OVERRIDE. This ensures that when base is derived from, Position is overridden</span></div>
<div class="line"><a class="code hl_function" href="group__adding__removing.html#ga2c5629a5ce9eac0414f5389b1e0266c0">ecs_add_id</a>(world, world, Base, <a class="code hl_variable" href="group__id__flags.html#ga14fab1e44fc00788bf3d9ebc4b032e5b">ECS_OVERRIDE</a> | ecs_id(Position));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create entity from BaseType. This adds the IsA relationship in addition</span></div>
<div class="line"><span class="comment">// to overriding Position, effectively initializing the Position component for the entity.</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, Base);</div>
<div class="ttc" id="agroup__id__flags_html_ga14fab1e44fc00788bf3d9ebc4b032e5b"><div class="ttname"><a href="group__id__flags.html#ga14fab1e44fc00788bf3d9ebc4b032e5b">ECS_OVERRIDE</a></div><div class="ttdeci">const ecs_id_t ECS_OVERRIDE</div><div class="ttdoc">Automatically override component when it is inherited.</div></div>
</div><!-- fragment --><p >The combination of instancing, overriding and OVERRIDE is one of the fastest and easiest ways to create an entity with a set of initialized components. The OVERRIDE relationship can also be specified inside type expressions. The following example is equivalent to the previous one:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga40af675acbf69a6cdc528d06d7533aef">ECS_ENTITY</a>(world, Base, Position, OVERRIDE | Position);</div>
<div class="line"> </div>
<div class="line">ecs_set(world, Base, Position, {10, 20});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, Base);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md164"></a>
Inheritance hierarchies</h2>
<p >If a base entity has children, derived entities of that base entity will, when the <code>IsA</code> relationship is added, acquire the same set of children. Take this example:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> parent = ecs_new(world, 0);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> child_1 = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a>, parent);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> child_2 = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a>, parent);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Derive from parent, two children are added to the entity</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, parent);</div>
</div><!-- fragment --><p >The children that are copied to the entity will have exactly the same set of components as the children of the base. For example, if the base child has components <code>Position, Velocity</code>, the derived child will also have <code>Position, Velocity</code>. Furthermore, the values of the base child components will be copied to the entity child:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> parent = ecs_new(world, 0);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> child = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a>, parent);</div>
<div class="line"><a class="code hl_function" href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a>(world, child, <span class="stringliteral">&quot;Child&quot;</span>); <span class="comment">// Give child a name, so we can look it up</span></div>
<div class="line">ecs_set(world, child, Position, {10, 20});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Derive from parent, two children are added to the derived entity</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, parent);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e_child = ecs_lookup_path(world, e, <span class="stringliteral">&quot;Child&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> Position *p = ecs_get(world, e_child, Position);</div>
<div class="line">printf(<span class="stringliteral">&quot;{%f, %f}\n&quot;</span>, p-&gt;x, p-&gt;y); <span class="comment">// Prints {10, 20}</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The components are not shared with the derived child!</span></div>
<div class="line">ecs_get(world, child, Position) != ecs_get(world, e_child, Position); <span class="comment">// 1</span></div>
</div><!-- fragment --><p >Since the children of the derived entity have the exact same components as the base children, their components are not shared. Component sharing between children is possible however, as <code>IsA</code> relationships are also copied over to the child of the derived entity:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> parent = ecs_new(world, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create child base from which we will share components</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> child_base = ecs_new(world, 0);</div>
<div class="line">ecs_set(world, child_base, Position, {10, 20});</div>
<div class="line"><a class="code hl_function" href="group__paths.html#ga8a031e32a628d7ff62c86d703cae33fb">ecs_set_name</a>(world, child, <span class="stringliteral">&quot;Child&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create actual child that inherits from the child base</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> child = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga804836ca51fb3ed3e7346ad084265236">EcsChildOf</a>, parent);</div>
<div class="line">ecs_add_pair(world, child, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, child_base);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Inherit from parent, two children are added to the entity</span></div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, <a class="code hl_variable" href="group__builtin__tags.html#ga61e41a3ca391d17da70b088989d9048b">EcsIsA</a>, parent);</div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e_child = ecs_lookup_path(world, e, <span class="stringliteral">&quot;Child&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The component is now shared with the child and child_base</span></div>
<div class="line">ecs_get(world, child, Position) == ecs_get(world, e_child, Position); <span class="comment">// 1</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md165"></a>
Prefabs</h2>
<p >Prefabs are entities that can be used as templates for other entities. Prefabs are regular entities, except that they are not matched by default with systems. To create a prefab, add the <code>EcsPrefab</code> tag when creating an entity:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> prefab = <a class="code hl_function" href="group__creating__entities.html#ga121c5b900576d74f970e31c78e2d4119">ecs_new_w_id</a>(world, <a class="code hl_variable" href="group__builtin__tags.html#gac126f3b4ccfa1d8ae3381fdfb97512e2">EcsPrefab</a>);</div>
<div class="ttc" id="agroup__builtin__tags_html_gac126f3b4ccfa1d8ae3381fdfb97512e2"><div class="ttname"><a href="group__builtin__tags.html#gac126f3b4ccfa1d8ae3381fdfb97512e2">EcsPrefab</a></div><div class="ttdeci">const ecs_entity_t EcsPrefab</div><div class="ttdoc">Tag added to prefab entities.</div></div>
</div><!-- fragment --><p >The <code>EcsPrefab</code> tag can also be added or removed dynamically:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__adding__removing.html#ga2c5629a5ce9eac0414f5389b1e0266c0">ecs_add_id</a>(world, prefab, <a class="code hl_variable" href="group__builtin__tags.html#gac126f3b4ccfa1d8ae3381fdfb97512e2">EcsPrefab</a>);</div>
<div class="line"><a class="code hl_function" href="group__adding__removing.html#ga553bb47a23309f088a6c7649656c36cb">ecs_remove_id</a>(world, prefab, <a class="code hl_variable" href="group__builtin__tags.html#gac126f3b4ccfa1d8ae3381fdfb97512e2">EcsPrefab</a>);</div>
</div><!-- fragment --><p >Prefabs can also be created with the <code>ECS_PREFAB</code> macro:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga8354485aaa3554a52832841d16bba1e8">ECS_PREFAB</a>(world, prefab, Position, Velocity);</div>
<div class="ttc" id="agroup__flecs__c__creation_html_ga8354485aaa3554a52832841d16bba1e8"><div class="ttname"><a href="group__flecs__c__creation.html#ga8354485aaa3554a52832841d16bba1e8">ECS_PREFAB</a></div><div class="ttdeci">#define ECS_PREFAB(world, id,...)</div><div class="ttdoc">Declare &amp; define a prefab.</div><div class="ttdef"><b>Definition:</b> <a href="flecs__c_8h_source.html#l00090">flecs_c.h:90</a></div></div>
</div><!-- fragment --><p >To instantiate a prefab, an application can use the <code>IsA</code> relationship:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, (IsA, prefab));</div>
</div><!-- fragment --><p >To ensure that entities that inherit from a prefab don't also inherit the <code>Prefab</code> tag (which would cause them to not get matched with systems), the <code>Prefab</code> tag does not propagate to derived entities. This is illustrated in the following example:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__flecs__c__creation.html#ga8354485aaa3554a52832841d16bba1e8">ECS_PREFAB</a>(world, prefab, Position);</div>
<div class="line"> </div>
<div class="line">ecs_has(world, prefab, <a class="code hl_variable" href="group__builtin__tags.html#gac126f3b4ccfa1d8ae3381fdfb97512e2">EcsPrefab</a>); <span class="comment">// true</span></div>
<div class="line">ecs_has(world, prefab, Position); <span class="comment">// true</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new_w_pair(world, (IsA, prefab));</div>
<div class="line">ecs_has(world, e, <a class="code hl_variable" href="group__builtin__tags.html#gac126f3b4ccfa1d8ae3381fdfb97512e2">EcsPrefab</a>); <span class="comment">// false</span></div>
<div class="line">ecs_has(world, e, Position); <span class="comment">// true</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md166"></a>
Deferred operations</h1>
<p >Applications can defer entity with the <code>ecs_defer_begin</code> and <code>ecs_defer_end</code> functions. This records all operations that happen inside the begin - end block, and executes them when <code>ecs_defer_end</code> is called. Deferred operations are useful when an application wants to make modifications to an entity while iterating, as doing this without deferring an operation could modify the underlying data structure. An example:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__commands.html#ga5270f6979821e334f94e2b45aaa0ddb2">ecs_defer_begin</a>(world);</div>
<div class="line">    <a class="code hl_typedef" href="group__core__types.html#ga7f68bc56147690fc4095ffb29b3679cc">ecs_entity_t</a> e = ecs_new(world, 0);</div>
<div class="line">    ecs_add(world, e, Position);</div>
<div class="line">    ecs_set(world, e, Velocity, {1, 1});</div>
<div class="line"><a class="code hl_function" href="group__commands.html#ga3de1f5d3387e3b958e0956bcacbdcbd6">ecs_defer_end</a>(world);</div>
<div class="ttc" id="agroup__commands_html_ga3de1f5d3387e3b958e0956bcacbdcbd6"><div class="ttname"><a href="group__commands.html#ga3de1f5d3387e3b958e0956bcacbdcbd6">ecs_defer_end</a></div><div class="ttdeci">bool ecs_defer_end(ecs_world_t *world)</div><div class="ttdoc">End block of operations to defer.</div></div>
<div class="ttc" id="agroup__commands_html_ga5270f6979821e334f94e2b45aaa0ddb2"><div class="ttname"><a href="group__commands.html#ga5270f6979821e334f94e2b45aaa0ddb2">ecs_defer_begin</a></div><div class="ttdeci">bool ecs_defer_begin(ecs_world_t *world)</div><div class="ttdoc">Defer operations until end of frame.</div></div>
</div><!-- fragment --><p >The effects of these operations will not be visible until the <code>ecs_defer_end</code> operation.</p>
<p >There are a few things to keep in mind when deferring:</p><ul>
<li>creating a new entity will always return a new id which increases the last used id counter of the world</li>
<li><code>ecs_get_mut</code> returns a pointer initialized with the current component value, and does not take into account deferred set or get_mut operations</li>
<li>if an operation is called on an entity which was deleted while deferred, the operation will ignored by <code>ecs_defer_end</code></li>
<li>if a child entity is created for a deleted parent while deferred, the child entity will be deleted by <code>ecs_defer_end</code> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
</body>
</html>
